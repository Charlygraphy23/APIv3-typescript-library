/**
 * SendinBlue API
 * SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@sendinblue.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.sendinblue.com/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AddChildDomain {
    /**
    * Sender domain to add for a specific child account
    */
    'domain': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddChildDomain.attributeTypeMap;
    }
}

export class AddContactToList {
    /**
    * Emails to add to a list
    */
    'emails': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AddContactToList.attributeTypeMap;
    }
}

export class AddCredits {
    /**
    * Required if email credits are empty. SMS credits to be added to the child account
    */
    'sms': number;
    /**
    * Required if sms credits are empty. Email credits to be added to the child account
    */
    'email': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AddCredits.attributeTypeMap;
    }
}

export class CreateAttribute {
    /**
    * Value of the attribute. Use only if the attribute's category is 'calculated' or 'global'
    */
    'value': string;
    /**
    * List of values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{'value':1, 'label':'male'}, {'value':2, 'label':'female'}]
    */
    'enumeration': Array<CreateAttributeEnumeration>;
    /**
    * Type of the attribute. Use only if the attribute's category is 'normal', 'category' or 'transactional' ( type 'boolean' is only available if the category is 'normal' attribute, type 'id' is only available if the category is 'transactional' attribute & type 'category' is only available if the category is 'category' attribute )
    */
    'type': CreateAttribute.TypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<CreateAttributeEnumeration>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CreateAttribute.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateAttribute.attributeTypeMap;
    }
}

export namespace CreateAttribute {
    export enum TypeEnum {
        Text = <any> 'text',
        Date = <any> 'date',
        Float = <any> 'float',
        Boolean = <any> 'boolean',
        Id = <any> 'id',
        Category = <any> 'category'
    }
}
export class CreateAttributeEnumeration {
    /**
    * Id of the value
    */
    'value': number;
    /**
    * Label of the value
    */
    'label': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAttributeEnumeration.attributeTypeMap;
    }
}

export class CreateChild {
    /**
    * Email address to create the child account
    */
    'email': string;
    /**
    * First name to use to create the child account
    */
    'firstName': string;
    /**
    * Last name to use to create the child account
    */
    'lastName': string;
    /**
    * Company name to use to create the child account
    */
    'companyName': string;
    /**
    * Password for the child account to login
    */
    'password': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateChild.attributeTypeMap;
    }
}

export class CreateContact {
    /**
    * Email address of the user. Mandatory if \"sms\" field is not passed in \"attributes\" parameter'
    */
    'email': string;
    /**
    * Pass the set of attributes and their values. These attributes must be present in your SendinBlue account. For eg. {'FNAME':'Elly', 'LNAME':'Roger'}
    */
    'attributes': any;
    /**
    * Set this field to blacklist the contact for emails (emailBlacklisted = true)
    */
    'emailBlacklisted': boolean;
    /**
    * Set this field to blacklist the contact for SMS (smsBlacklisted = true)
    */
    'smsBlacklisted': boolean;
    /**
    * Ids of the lists to add the contact to
    */
    'listIds': Array<number>;
    /**
    * Facilitate to update the existing contact in the same request (updateEnabled = true)
    */
    'updateEnabled': boolean;
    /**
    * transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled = true )
    */
    'smtpBlacklistSender': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "updateEnabled",
            "baseName": "updateEnabled",
            "type": "boolean"
        },
        {
            "name": "smtpBlacklistSender",
            "baseName": "smtpBlacklistSender",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateContact.attributeTypeMap;
    }
}

export class CreateEmailCampaign {
    /**
    * Tag of the campaign
    */
    'tag': string;
    'sender': CreateEmailCampaignSender;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Mandatory if htmlUrl and templateId are empty. Body of the message (HTML)
    */
    'htmlContent': string;
    /**
    * Mandatory if htmlContent and templateId are empty. Url to the message (HTML)
    */
    'htmlUrl': string;
    /**
    * Mandatory if htmlContent and htmlUrl are empty. Id of the transactional email template with status 'active'. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.
    */
    'templateId': number;
    /**
    * Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
    */
    'scheduledAt': Date;
    /**
    * Subject of the campaign. Mandatory if abTesting is false. Ignored if abTesting is true.
    */
    'subject': string;
    /**
    * Email on which the campaign recipients will be able to reply to
    */
    'replyTo': string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField': string;
    'recipients': CreateEmailCampaignRecipients;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl': string;
    /**
    * Use true to embedded the images in your email. Final size of the email should be less than 4MB. Campaigns with embedded images can not be sent to more than 5000 contacts
    */
    'inlineImageActivation': boolean;
    /**
    * Use true to enable the mirror link
    */
    'mirrorActive': boolean;
    /**
    * Footer of the email campaign
    */
    'footer': string;
    /**
    * Header of the email campaign
    */
    'header': string;
    /**
    * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
    */
    'utmCampaign': string;
    /**
    * Pass the set of attributes to customize the type classic campaign. For example, {'FNAME':'Joe', 'LNAME':'Doe'}. Only available if 'type' is 'classic'. It's considered only if campaign is in New Template Language format. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
    */
    'params': any;
    /**
    * Set this to true if you want to send your campaign at best time.
    */
    'sendAtBestTime': boolean;
    /**
    * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered when abTesting is set to true. 'subjectA' & 'subjectB' are mandatory together & 'subject' if passed is ignored. Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
    */
    'abTesting': boolean;
    /**
    * Subject A of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectA': string;
    /**
    * Subject B of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectB': string;
    /**
    * Add the size of your test groups. Mandatory if abTesting = true & 'recipients' is passed. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
    */
    'splitRule': number;
    /**
    * Choose the metrics that will determinate the winning version. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed
    */
    'winnerCriteria': CreateEmailCampaign.WinnerCriteriaEnum;
    /**
    * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed
    */
    'winnerDelay': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "CreateEmailCampaignSender"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateEmailCampaignRecipients"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "CreateEmailCampaign.WinnerCriteriaEnum"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaign.attributeTypeMap;
    }
}

export namespace CreateEmailCampaign {
    export enum WinnerCriteriaEnum {
        Open = <any> 'open',
        Click = <any> 'click'
    }
}
/**
* List ids to include/exclude from campaign
*/
export class CreateEmailCampaignRecipients {
    /**
    * List ids to exclude from the campaign
    */
    'exclusionListIds': Array<number>;
    /**
    * Mandatory if scheduledAt is not empty. List Ids to send the campaign to
    */
    'listIds': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaignRecipients.attributeTypeMap;
    }
}

/**
* Sender details including email and name (optional). For example {'name':'xyz' , 'email':'example@abc.com'}
*/
export class CreateEmailCampaignSender {
    /**
    * Sender Name
    */
    'name': string;
    /**
    * Sender email
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaignSender.attributeTypeMap;
    }
}

export class CreateList {
    /**
    * Name of the list
    */
    'name': string;
    /**
    * Id of the parent folder in which this list is to be created
    */
    'folderId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateList.attributeTypeMap;
    }
}

export class CreateModel {
    /**
    * ID of the object created
    */
    'id': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateModel.attributeTypeMap;
    }
}

export class CreateReseller {
    /**
    * AuthKey of Reseller child created
    */
    'authKey': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authKey",
            "baseName": "authKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateReseller.attributeTypeMap;
    }
}

export class CreateSender {
    /**
    * From Name to use for the sender
    */
    'name': string;
    /**
    * From Email to use for the sender
    */
    'email': string;
    /**
    * Mandatory in case of dedicated IP, IPs to associate to the sender
    */
    'ips': Array<CreateSenderIps>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<CreateSenderIps>"
        }    ];

    static getAttributeTypeMap() {
        return CreateSender.attributeTypeMap;
    }
}

export class CreateSenderIps {
    /**
    * Dedicated IP available in your account
    */
    'ip': string;
    /**
    * Domain of the IP
    */
    'domain': string;
    /**
    * Weight to apply to the IP. Sum of all IP weights must be 100. Should be passed for either ALL or NONE of the IPs. If it's not passed, the sending will be equally balanced on all IPs.
    */
    'weight': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateSenderIps.attributeTypeMap;
    }
}

export class CreateSenderModel {
    /**
    * ID of the Sender created
    */
    'id': number;
    /**
    * Status of SPF configuration for the sender (true = SPF not well configured, false = SPF well configured)
    */
    'spfError': boolean;
    /**
    * Status of DKIM configuration for the sender (true = DKIM not well configured, false = DKIM well configured)
    */
    'dkimError': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "spfError",
            "baseName": "spfError",
            "type": "boolean"
        },
        {
            "name": "dkimError",
            "baseName": "dkimError",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateSenderModel.attributeTypeMap;
    }
}

export class CreateSmsCampaign {
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Name of the sender. The number of characters is limited to 11
    */
    'sender': string;
    /**
    * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
    */
    'content': string;
    'recipients': CreateSmsCampaignRecipients;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
    */
    'scheduledAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateSmsCampaignRecipients"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmsCampaign.attributeTypeMap;
    }
}

export class CreateSmsCampaignRecipients {
    /**
    * Lists Ids to send the campaign to. REQUIRED if scheduledAt is not empty
    */
    'listIds': Array<number>;
    /**
    * List ids which have to be excluded from a campaign
    */
    'exclusionListIds': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmsCampaignRecipients.attributeTypeMap;
    }
}

export class CreateSmtpEmail {
    /**
    * Message ID of the transactional email sent
    */
    'messageId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpEmail.attributeTypeMap;
    }
}

export class CreateSmtpTemplate {
    /**
    * Tag of the template
    */
    'tag': string;
    'sender': CreateSmtpTemplateSender;
    /**
    * Name of the template
    */
    'templateName': string;
    /**
    * Body of the message (HTML version). The field must have more than 10 characters. REQUIRED if htmlUrl is empty
    */
    'htmlContent': string;
    /**
    * Url which contents the body of the email message. REQUIRED if htmlContent is empty
    */
    'htmlUrl': string;
    /**
    * Subject of the template
    */
    'subject': string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo': string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField': string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl': string;
    /**
    * Status of template. isActive = true means template is active and isActive = false means template is inactive
    */
    'isActive': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "CreateSmtpTemplateSender"
        },
        {
            "name": "templateName",
            "baseName": "templateName",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpTemplate.attributeTypeMap;
    }
}

/**
* Sender details including email and name (optional). For example {'name':'xyz' , 'email':'example@abc.com'}
*/
export class CreateSmtpTemplateSender {
    /**
    * Name of the sender. If not passed, will be set to default
    */
    'name': string;
    /**
    * Email of the sender
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpTemplateSender.attributeTypeMap;
    }
}

export class CreateUpdateContactModel {
    /**
    * ID of the contact when a new contact is created
    */
    'id': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateUpdateContactModel.attributeTypeMap;
    }
}

export class CreateUpdateFolder {
    /**
    * Name of the folder
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateUpdateFolder.attributeTypeMap;
    }
}

export class CreateWebhook {
    /**
    * URL of the webhook
    */
    'url': string;
    /**
    * Description of the webhook
    */
    'description': string;
    /**
    * Events triggering the webhook. Possible values for Transactional type webhook – request, delivered, hardBounce, softBounce, blocked, spam, invalid, deferred, click, opened, uniqueOpened and unsubscribed and possible values for Marketing type webhook – spam, opened, click, hardBounce, softBounce, unsubscribed, listAddition & delivered
    */
    'events': Array<CreateWebhook.EventsEnum>;
    /**
    * Type of the webhook
    */
    'type': CreateWebhook.TypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<CreateWebhook.EventsEnum>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CreateWebhook.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateWebhook.attributeTypeMap;
    }
}

export namespace CreateWebhook {
    export enum EventsEnum {
        HardBounce = <any> 'hardBounce',
        SoftBounce = <any> 'softBounce',
        Blocked = <any> 'blocked',
        Spam = <any> 'spam',
        Delivered = <any> 'delivered',
        Request = <any> 'request',
        Click = <any> 'click',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Opened = <any> 'opened',
        UniqueOpened = <any> 'uniqueOpened',
        Unsubscribed = <any> 'unsubscribed',
        ListAddition = <any> 'listAddition',
        ContactUpdated = <any> 'contactUpdated',
        ContactDeleted = <any> 'contactDeleted'
    }
    export enum TypeEnum {
        Transactional = <any> 'transactional',
        Marketing = <any> 'marketing'
    }
}
export class CreatedProcessId {
    /**
    * Id of the process created
    */
    'processId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processId",
            "baseName": "processId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreatedProcessId.attributeTypeMap;
    }
}

export class DeleteHardbounces {
    /**
    * Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate
    */
    'startDate': string;
    /**
    * Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate
    */
    'endDate': string;
    /**
    * Target a specific email address
    */
    'contactEmail': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "contactEmail",
            "baseName": "contactEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteHardbounces.attributeTypeMap;
    }
}

export class EmailExportRecipients {
    /**
    * Webhook called once the export process is finished
    */
    'notifyURL': string;
    /**
    * Type of recipients to export for a campaign
    */
    'recipientsType': EmailExportRecipients.RecipientsTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifyURL",
            "baseName": "notifyURL",
            "type": "string"
        },
        {
            "name": "recipientsType",
            "baseName": "recipientsType",
            "type": "EmailExportRecipients.RecipientsTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return EmailExportRecipients.attributeTypeMap;
    }
}

export namespace EmailExportRecipients {
    export enum RecipientsTypeEnum {
        All = <any> 'all',
        NonClickers = <any> 'nonClickers',
        NonOpeners = <any> 'nonOpeners',
        Clickers = <any> 'clickers',
        Openers = <any> 'openers',
        SoftBounces = <any> 'softBounces',
        HardBounces = <any> 'hardBounces',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class ErrorModel {
    /**
    * Error code displayed in case of a failure
    */
    'code': ErrorModel.CodeEnum;
    /**
    * Readable message associated to the failure
    */
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "ErrorModel.CodeEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorModel.attributeTypeMap;
    }
}

export namespace ErrorModel {
    export enum CodeEnum {
        InvalidParameter = <any> 'invalid_parameter',
        MissingParameter = <any> 'missing_parameter',
        OutOfRange = <any> 'out_of_range',
        CampaignProcessing = <any> 'campaign_processing',
        CampaignSent = <any> 'campaign_sent',
        DocumentNotFound = <any> 'document_not_found',
        ResellerPermissionDenied = <any> 'reseller_permission_denied',
        NotEnoughCredits = <any> 'not_enough_credits',
        PermissionDenied = <any> 'permission_denied',
        DuplicateParameter = <any> 'duplicate_parameter',
        DuplicateRequest = <any> 'duplicate_request',
        MethodNotAllowed = <any> 'method_not_allowed',
        Unauthorized = <any> 'unauthorized',
        AccountUnderValidation = <any> 'account_under_validation',
        NotAcceptable = <any> 'not_acceptable'
    }
}
export class GetAccountMarketingAutomation {
    /**
    * Marketing Automation Tracker ID
    */
    'key': string;
    /**
    * Status of Marketing Automation Plateform activation for your account (true=enabled, false=disabled)
    */
    'enabled': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountMarketingAutomation.attributeTypeMap;
    }
}

export class GetAccountPlan {
    /**
    * Displays the plan type of the user
    */
    'type': GetAccountPlan.TypeEnum;
    /**
    * This is the type of the credit, \"Send Limit\" is one of the possible types of credit of a user. \"Send Limit\" implies the total number of emails you can send to the subscribers in your account.
    */
    'creditsType': GetAccountPlan.CreditsTypeEnum;
    /**
    * Remaining credits of the user
    */
    'credits': number;
    /**
    * Date of the period from which the plan will start (only available for \"subscription\" and \"reseller\" plan type)
    */
    'startDate': string;
    /**
    * Date of the period from which the plan will end (only available for \"subscription\" and \"reseller\" plan type)
    */
    'endDate': string;
    /**
    * Only in case of reseller account. It implies the total number of child accounts you can add to your account.
    */
    'userLimit': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "GetAccountPlan.TypeEnum"
        },
        {
            "name": "creditsType",
            "baseName": "creditsType",
            "type": "GetAccountPlan.CreditsTypeEnum"
        },
        {
            "name": "credits",
            "baseName": "credits",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "userLimit",
            "baseName": "userLimit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountPlan.attributeTypeMap;
    }
}

export namespace GetAccountPlan {
    export enum TypeEnum {
        PayAsYouGo = <any> 'payAsYouGo',
        Free = <any> 'free',
        Subscription = <any> 'subscription',
        Sms = <any> 'sms',
        Reseller = <any> 'reseller'
    }
    export enum CreditsTypeEnum {
        SendLimit = <any> 'sendLimit'
    }
}
/**
* Information about your transactional email account
*/
export class GetAccountRelay {
    /**
    * Status of your transactional email Account (true=Enabled, false=Disabled)
    */
    'enabled': boolean;
    'data': GetAccountRelayData;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "GetAccountRelayData"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountRelay.attributeTypeMap;
    }
}

/**
* Data regarding the transactional email account
*/
export class GetAccountRelayData {
    /**
    * Email to use as login on transactional platform
    */
    'userName': string;
    /**
    * URL of the SMTP Relay
    */
    'relay': string;
    /**
    * Port used for SMTP Relay
    */
    'port': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "relay",
            "baseName": "relay",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountRelayData.attributeTypeMap;
    }
}

export class GetAggregatedReport {
    /**
    * Time frame of the report
    */
    'range': string;
    /**
    * Number of requests for the timeframe
    */
    'requests': number;
    /**
    * Number of delivered emails for the timeframe
    */
    'delivered': number;
    /**
    * Number of hardbounces for the timeframe
    */
    'hardBounces': number;
    /**
    * Number of softbounces for the timeframe
    */
    'softBounces': number;
    /**
    * Number of clicks for the timeframe
    */
    'clicks': number;
    /**
    * Number of unique clicks for the timeframe
    */
    'uniqueClicks': number;
    /**
    * Number of openings for the timeframe
    */
    'opens': number;
    /**
    * Number of unique openings for the timeframe
    */
    'uniqueOpens': number;
    /**
    * Number of complaint (spam report) for the timeframe
    */
    'spamReports': number;
    /**
    * Number of blocked contact emails for the timeframe
    */
    'blocked': number;
    /**
    * Number of invalid emails for the timeframe
    */
    'invalid': number;
    /**
    * Number of unsubscribed emails for the timeframe
    */
    'unsubscribed': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "range",
            "baseName": "range",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "opens",
            "baseName": "opens",
            "type": "number"
        },
        {
            "name": "uniqueOpens",
            "baseName": "uniqueOpens",
            "type": "number"
        },
        {
            "name": "spamReports",
            "baseName": "spamReports",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "invalid",
            "baseName": "invalid",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAggregatedReport.attributeTypeMap;
    }
}

export class GetAttributes {
    /**
    * Listing of available contact attributes in your account
    */
    'attributes': Array<GetAttributesAttributes>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<GetAttributesAttributes>"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributes.attributeTypeMap;
    }
}

export class GetAttributesAttributes {
    /**
    * Name of the attribute
    */
    'name': string;
    /**
    * Category of the attribute
    */
    'category': GetAttributesAttributes.CategoryEnum;
    /**
    * Type of the attribute
    */
    'type': GetAttributesAttributes.TypeEnum;
    /**
    * Parameter only available for \"category\" type attributes.
    */
    'enumeration': Array<GetAttributesEnumeration>;
    /**
    * Calculated value formula
    */
    'calculatedValue': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "GetAttributesAttributes.CategoryEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetAttributesAttributes.TypeEnum"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<GetAttributesEnumeration>"
        },
        {
            "name": "calculatedValue",
            "baseName": "calculatedValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributesAttributes.attributeTypeMap;
    }
}

export namespace GetAttributesAttributes {
    export enum CategoryEnum {
        Normal = <any> 'normal',
        Transactional = <any> 'transactional',
        Category = <any> 'category',
        Calculated = <any> 'calculated',
        Global = <any> 'global'
    }
    export enum TypeEnum {
        Text = <any> 'text',
        Date = <any> 'date',
        Float = <any> 'float',
        Id = <any> 'id',
        Boolean = <any> 'boolean'
    }
}
export class GetAttributesEnumeration {
    /**
    * ID of Value of the \"category\" type attribute
    */
    'value': number;
    /**
    * Label of the \"category\" type attribute
    */
    'label': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributesEnumeration.attributeTypeMap;
    }
}

export class GetCampaignOverview {
    /**
    * ID of the campaign
    */
    'id': number;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
    */
    'subject': string;
    /**
    * Type of campaign
    */
    'type': GetCampaignOverview.TypeEnum;
    /**
    * Status of the campaign
    */
    'status': GetCampaignOverview.StatusEnum;
    /**
    * UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'scheduledAt': Date;
    /**
    * Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.
    */
    'abTesting': boolean;
    /**
    * Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectA': string;
    /**
    * Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectB': string;
    /**
    * The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`
    */
    'splitRule': number;
    /**
    * Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerCriteria': string;
    /**
    * The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerDelay': number;
    /**
    * It is true if you have chosen to send your campaign at best time, otherwise it is false
    */
    'sendAtBestTime': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetCampaignOverview.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCampaignOverview.StatusEnum"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "string"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignOverview.attributeTypeMap;
    }
}

export namespace GetCampaignOverview {
    export enum TypeEnum {
        Classic = <any> 'classic',
        Trigger = <any> 'trigger'
    }
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'in_process'
    }
}
export class GetCampaignRecipients {
    'lists': Array<number>;
    'exclusionLists': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<number>"
        },
        {
            "name": "exclusionLists",
            "baseName": "exclusionLists",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignRecipients.attributeTypeMap;
    }
}

export class GetCampaignStats {
    /**
    * List Id of email campaign (only in case of get email campaign(s)(not for global stats))
    */
    'listId': number;
    /**
    * Number of unique clicks for the campaign
    */
    'uniqueClicks': number;
    /**
    * Number of total clicks for the campaign
    */
    'clickers': number;
    /**
    * Number of complaints (Spam reports) for the campaign
    */
    'complaints': number;
    /**
    * Number of delivered emails for the campaign
    */
    'delivered': number;
    /**
    * Number of sent emails for the campaign
    */
    'sent': number;
    /**
    * Number of softbounce for the campaign
    */
    'softBounces': number;
    /**
    * Number of harbounce for the campaign
    */
    'hardBounces': number;
    /**
    * Number of unique openings for the campaign
    */
    'uniqueViews': number;
    /**
    * Number of unsubscription for the campaign
    */
    'unsubscriptions': number;
    /**
    * Number of openings for the campaign
    */
    'viewed': number;
    /**
    * Number of deferred emails for the campaign
    */
    'deferred': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listId",
            "baseName": "listId",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "clickers",
            "baseName": "clickers",
            "type": "number"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "sent",
            "baseName": "sent",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "uniqueViews",
            "baseName": "uniqueViews",
            "type": "number"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "number"
        },
        {
            "name": "viewed",
            "baseName": "viewed",
            "type": "number"
        },
        {
            "name": "deferred",
            "baseName": "deferred",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignStats.attributeTypeMap;
    }
}

export class GetChildDomain {
    /**
    * Sender domain
    */
    'domain': string;
    /**
    * indicates whether a domain is verified or not
    */
    'active': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetChildDomain.attributeTypeMap;
    }
}

export class GetChildDomains extends Array<any> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetChildDomains.attributeTypeMap);
    }
}

/**
* API Keys associated to child account
*/
export class GetChildInfoApiKeys {
    'v2': Array<GetChildInfoApiKeysV2>;
    'v3': Array<GetChildInfoApiKeysV3>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "v2",
            "baseName": "v2",
            "type": "Array<GetChildInfoApiKeysV2>"
        },
        {
            "name": "v3",
            "baseName": "v3",
            "type": "Array<GetChildInfoApiKeysV3>"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeys.attributeTypeMap;
    }
}

export class GetChildInfoApiKeysV2 {
    /**
    * Name of the key for version 2
    */
    'name': string;
    /**
    * API Key for version 2
    */
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeysV2.attributeTypeMap;
    }
}

export class GetChildInfoApiKeysV3 {
    /**
    * Name of the key for version 3
    */
    'name': string;
    /**
    * API Key for version 3
    */
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeysV3.attributeTypeMap;
    }
}

/**
* Credits available for your child
*/
export class GetChildInfoCredits {
    /**
    * Email credits available for your child
    */
    'emailCredits': number;
    /**
    * SMS credits available for your child
    */
    'smsCredits': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailCredits",
            "baseName": "emailCredits",
            "type": "number"
        },
        {
            "name": "smsCredits",
            "baseName": "smsCredits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoCredits.attributeTypeMap;
    }
}

/**
* Statistics about your child account activity
*/
export class GetChildInfoStatistics {
    /**
    * Overall emails sent for the previous month
    */
    'previousMonthTotalSent': number;
    /**
    * Overall emails sent for current month
    */
    'currentMonthTotalSent': number;
    /**
    * Overall emails sent for since the account exists
    */
    'totalSent': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousMonthTotalSent",
            "baseName": "previousMonthTotalSent",
            "type": "number"
        },
        {
            "name": "currentMonthTotalSent",
            "baseName": "currentMonthTotalSent",
            "type": "number"
        },
        {
            "name": "totalSent",
            "baseName": "totalSent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoStatistics.attributeTypeMap;
    }
}

export class GetChildrenList {
    /**
    * Your children's account information
    */
    'children': Array<any>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return GetChildrenList.attributeTypeMap;
    }
}

export class GetClient {
    /**
    * Login Email
    */
    'email': string;
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Name of the company
    */
    'companyName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetClient.attributeTypeMap;
    }
}

/**
* Campaign Statistics for the contact
*/
export class GetContactCampaignStats {
    'messagesSent': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'hardBounces': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'softBounces': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'complaints': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'unsubscriptions': GetContactCampaignStatsUnsubscriptions;
    'opened': Array<GetContactCampaignStatsOpened>;
    'clicked': Array<GetContactCampaignStatsClicked>;
    'transacAttributes': Array<GetContactCampaignStatsTransacAttributes>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messagesSent",
            "baseName": "messagesSent",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "GetContactCampaignStatsUnsubscriptions"
        },
        {
            "name": "opened",
            "baseName": "opened",
            "type": "Array<GetContactCampaignStatsOpened>"
        },
        {
            "name": "clicked",
            "baseName": "clicked",
            "type": "Array<GetContactCampaignStatsClicked>"
        },
        {
            "name": "transacAttributes",
            "baseName": "transacAttributes",
            "type": "Array<GetContactCampaignStatsTransacAttributes>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStats.attributeTypeMap;
    }
}

export class GetContactCampaignStatsClicked {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    'links': Array<GetExtendedContactDetailsStatisticsLinks>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<GetExtendedContactDetailsStatisticsLinks>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsClicked.attributeTypeMap;
    }
}

export class GetContactCampaignStatsOpened {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Number of openings of the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;
    /**
    * IP from which the user has opened the campaign
    */
    'ip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsOpened.attributeTypeMap;
    }
}

export class GetContactCampaignStatsTransacAttributes {
    /**
    * Date of the order
    */
    'orderDate': string;
    /**
    * Price of the order
    */
    'orderPrice': number;
    /**
    * ID of the order
    */
    'orderId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderDate",
            "baseName": "orderDate",
            "type": "string"
        },
        {
            "name": "orderPrice",
            "baseName": "orderPrice",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "orderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsTransacAttributes.attributeTypeMap;
    }
}

export class GetContactCampaignStatsUnsubscriptions {
    /**
    * Contact has unsubscribed via the unsubscription link in the email
    */
    'userUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
    /**
    * Contact has been unsubscribed from the administrator
    */
    'adminUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userUnsubscription",
            "baseName": "userUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>"
        },
        {
            "name": "adminUnsubscription",
            "baseName": "adminUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsUnsubscriptions.attributeTypeMap;
    }
}

export class GetContactDetails {
    /**
    * Email address of the contact for which you requested the details
    */
    'email': string;
    /**
    * ID of the contact for which you requested the details
    */
    'id': number;
    /**
    * Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
    */
    'emailBlacklisted': boolean;
    /**
    * Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
    */
    'smsBlacklisted': boolean;
    /**
    * Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;
    'listIds': Array<number>;
    'listUnsubscribed': Array<number>;
    /**
    * Set of attributes of the contact
    */
    'attributes': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "listUnsubscribed",
            "baseName": "listUnsubscribed",
            "type": "Array<number>"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return GetContactDetails.attributeTypeMap;
    }
}

export class GetContacts {
    'contacts': Array<any>;
    /**
    * Number of contacts
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContacts.attributeTypeMap;
    }
}

export class GetEmailCampaigns {
    'campaigns': Array<any>;
    /**
    * Number of Email campaigns retrieved
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailCampaigns.attributeTypeMap;
    }
}

export class GetEmailEventReport {
    'events': Array<GetEmailEventReportEvents>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetEmailEventReportEvents>"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailEventReport.attributeTypeMap;
    }
}

export class GetEmailEventReportEvents {
    /**
    * Email address which generates the event
    */
    'email': string;
    /**
    * UTC date-time on which the event has been generated
    */
    'date': Date;
    /**
    * Subject of the event
    */
    'subject': string;
    /**
    * Message ID which generated the event
    */
    'messageId': string;
    /**
    * Event which occurred
    */
    'event': GetEmailEventReportEvents.EventEnum;
    /**
    * Reason of bounce (only available if the event is hardbounce or softbounce)
    */
    'reason': string;
    /**
    * Tag of the email which generated the event
    */
    'tag': string;
    /**
    * IP from which the user has opened the email or clicked on the link (only available if the event is opened or clicks)
    */
    'ip': string;
    /**
    * The link which is sent to the user (only available if the event is requests or opened or clicks)
    */
    'link': string;
    /**
    * Sender email from which the emails are sent
    */
    'from': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "GetEmailEventReportEvents.EventEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailEventReportEvents.attributeTypeMap;
    }
}

export namespace GetEmailEventReportEvents {
    export enum EventEnum {
        Bounces = <any> 'bounces',
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces',
        Delivered = <any> 'delivered',
        Spam = <any> 'spam',
        Requests = <any> 'requests',
        Opened = <any> 'opened',
        Clicks = <any> 'clicks',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Blocked = <any> 'blocked',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class GetExtendedCampaignOverviewSender {
    /**
    * Sender name of the campaign
    */
    'name': string;
    /**
    * Sender email of the campaign
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignOverviewSender.attributeTypeMap;
    }
}

export class GetExtendedCampaignStats {
    /**
    * Overall statistics of the campaign
    */
    'globalStats': any;
    /**
    * List-wise statistics of the campaign.
    */
    'campaignStats': Array<any>;
    /**
    * Number of clicks on mirror link
    */
    'mirrorClick': number;
    /**
    * Number of remaning emails to send
    */
    'remaining': number;
    /**
    * Statistics about the number of clicks for the links
    */
    'linksStats': any;
    'statsByDomain': GetStatsByDomain;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "globalStats",
            "baseName": "globalStats",
            "type": "any"
        },
        {
            "name": "campaignStats",
            "baseName": "campaignStats",
            "type": "Array<any>"
        },
        {
            "name": "mirrorClick",
            "baseName": "mirrorClick",
            "type": "number"
        },
        {
            "name": "remaining",
            "baseName": "remaining",
            "type": "number"
        },
        {
            "name": "linksStats",
            "baseName": "linksStats",
            "type": "any"
        },
        {
            "name": "statsByDomain",
            "baseName": "statsByDomain",
            "type": "GetStatsByDomain"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignStats.attributeTypeMap;
    }
}

/**
* Address informations
*/
export class GetExtendedClientAddress {
    /**
    * Street information
    */
    'street': string;
    /**
    * City information
    */
    'city': string;
    /**
    * Zip Code information
    */
    'zipCode': string;
    /**
    * Country information
    */
    'country': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "zipCode",
            "baseName": "zipCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedClientAddress.attributeTypeMap;
    }
}

/**
* Campaign statistics of the contact
*/
export class GetExtendedContactDetailsStatistics {
    /**
    * Listing of the sent campaign for the contact
    */
    'messagesSent': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the hardbounes generated by the contact
    */
    'hardBounces': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the softbounes generated by the contact
    */
    'softBounces': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the complaints generated by the contact
    */
    'complaints': Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'unsubscriptions': GetExtendedContactDetailsStatisticsUnsubscriptions;
    /**
    * Listing of the openings generated by the contact
    */
    'opened': Array<GetExtendedContactDetailsStatisticsOpened>;
    /**
    * Listing of the clicks generated by the contact
    */
    'clicked': Array<GetExtendedContactDetailsStatisticsClicked>;
    /**
    * Listing of the transactional attributes for the contact
    */
    'transacAttributes': Array<any>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messagesSent",
            "baseName": "messagesSent",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "GetExtendedContactDetailsStatisticsUnsubscriptions"
        },
        {
            "name": "opened",
            "baseName": "opened",
            "type": "Array<GetExtendedContactDetailsStatisticsOpened>"
        },
        {
            "name": "clicked",
            "baseName": "clicked",
            "type": "Array<GetExtendedContactDetailsStatisticsClicked>"
        },
        {
            "name": "transacAttributes",
            "baseName": "transacAttributes",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatistics.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsClicked {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Listing of the clicked links for the campaign
    */
    'links': Array<GetExtendedContactDetailsStatisticsLinks>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<GetExtendedContactDetailsStatisticsLinks>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsClicked.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsLinks {
    /**
    * Number of clicks on this link for the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;
    /**
    * IP from which the user has clicked on the link
    */
    'ip': string;
    /**
    * URL of the clicked link
    */
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsLinks.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsMessagesSent {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsMessagesSent.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsOpened {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Number of openings for the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;
    /**
    * IP from which the user has opened the email
    */
    'ip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsOpened.attributeTypeMap;
    }
}

/**
* Listing of the unsubscription for the contact
*/
export class GetExtendedContactDetailsStatisticsUnsubscriptions {
    /**
    * Contact unsubscribe via unsubscription link in a campaign
    */
    'userUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
    /**
    * Contact has been unsubscribed from the administrator
    */
    'adminUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userUnsubscription",
            "baseName": "userUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>"
        },
        {
            "name": "adminUnsubscription",
            "baseName": "adminUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptions.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription {
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;
    /**
    * IP from which the user has been unsubscribed
    */
    'ip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': Date;
    /**
    * IP from which the user has unsubscribed
    */
    'ip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "Date"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription.attributeTypeMap;
    }
}

export class GetExtendedListCampaignStats {
    /**
    * ID of the campaign
    */
    'campaignId': number;
    'stats': GetCampaignStats;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "GetCampaignStats"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedListCampaignStats.attributeTypeMap;
    }
}

export class GetFolder {
    /**
    * ID of the folder
    */
    'id': number;
    /**
    * Name of the folder
    */
    'name': string;
    /**
    * Number of blacklisted contacts in the folder
    */
    'totalBlacklisted': number;
    /**
    * Number of contacts in the folder
    */
    'totalSubscribers': number;
    /**
    * Number of unique contacts in the folder
    */
    'uniqueSubscribers': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalBlacklisted",
            "baseName": "totalBlacklisted",
            "type": "number"
        },
        {
            "name": "totalSubscribers",
            "baseName": "totalSubscribers",
            "type": "number"
        },
        {
            "name": "uniqueSubscribers",
            "baseName": "uniqueSubscribers",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolder.attributeTypeMap;
    }
}

export class GetFolderLists {
    'lists': Array<any>;
    /**
    * Number of lists in the folder
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolderLists.attributeTypeMap;
    }
}

export class GetFolders {
    'folders': Array<any>;
    /**
    * Number of folders available in your account
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "folders",
            "baseName": "folders",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolders.attributeTypeMap;
    }
}

export class GetIp {
    /**
    * ID of the dedicated IP
    */
    'id': number;
    /**
    * Dedicated IP
    */
    'ip': string;
    /**
    * Status of the IP (true=active, false=inactive)
    */
    'active': boolean;
    /**
    * Domain associated to the IP
    */
    'domain': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetIp.attributeTypeMap;
    }
}

export class GetIpFromSender {
    /**
    * ID of the dedicated IP
    */
    'id': number;
    /**
    * Dedicated IP
    */
    'ip': string;
    /**
    * Domain associated to the IP
    */
    'domain': string;
    /**
    * Weight of the IP
    */
    'weight': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetIpFromSender.attributeTypeMap;
    }
}

export class GetIps {
    /**
    * Dedicated IP(s) available on your account
    */
    'ips': Array<GetIp>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetIp>"
        }    ];

    static getAttributeTypeMap() {
        return GetIps.attributeTypeMap;
    }
}

export class GetIpsFromSender {
    /**
    * Dedicated IP(s) linked to a sender
    */
    'ips': Array<GetIpFromSender>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetIpFromSender>"
        }    ];

    static getAttributeTypeMap() {
        return GetIpsFromSender.attributeTypeMap;
    }
}

export class GetList {
    /**
    * ID of the list
    */
    'id': number;
    /**
    * Name of the list
    */
    'name': string;
    /**
    * Number of blacklisted contacts in the list
    */
    'totalBlacklisted': number;
    /**
    * Number of contacts in the list
    */
    'totalSubscribers': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalBlacklisted",
            "baseName": "totalBlacklisted",
            "type": "number"
        },
        {
            "name": "totalSubscribers",
            "baseName": "totalSubscribers",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetList.attributeTypeMap;
    }
}

export class GetLists {
    /**
    * Listing of all the lists available in your account
    */
    'lists': Array<any>;
    /**
    * Number of lists in your account
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetLists.attributeTypeMap;
    }
}

export class GetProcess {
    /**
    * Id of the process
    */
    'id': number;
    /**
    * Status of the process
    */
    'status': GetProcess.StatusEnum;
    /**
    * Process name
    */
    'name': string;
    /**
    * URL on which send export the of contacts once the process is completed
    */
    'exportUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetProcess.StatusEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "exportUrl",
            "baseName": "export_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetProcess.attributeTypeMap;
    }
}

export namespace GetProcess {
    export enum StatusEnum {
        Queued = <any> 'queued',
        InProcess = <any> 'in_process',
        Completed = <any> 'completed'
    }
}
export class GetProcesses {
    /**
    * List of processes available on your account
    */
    'processes': Array<GetProcess>;
    /**
    * Number of processes available on your account
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processes",
            "baseName": "processes",
            "type": "Array<GetProcess>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetProcesses.attributeTypeMap;
    }
}

export class GetReports {
    'reports': Array<GetReportsReports>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reports",
            "baseName": "reports",
            "type": "Array<GetReportsReports>"
        }    ];

    static getAttributeTypeMap() {
        return GetReports.attributeTypeMap;
    }
}

export class GetReportsReports {
    /**
    * Date of the statistics
    */
    'date': string;
    /**
    * Number of requests for the date
    */
    'requests': number;
    /**
    * Number of delivered emails for the date
    */
    'delivered': number;
    /**
    * Number of hardbounces for the date
    */
    'hardBounces': number;
    /**
    * Number of softbounces for the date
    */
    'softBounces': number;
    /**
    * Number of clicks for the date
    */
    'clicks': number;
    /**
    * Number of unique clicks for the date
    */
    'uniqueClicks': number;
    /**
    * Number of openings for the date
    */
    'opens': number;
    /**
    * Number of unique openings for the date
    */
    'uniqueOpens': number;
    /**
    * Number of complaints (spam reports) for the date
    */
    'spamReports': number;
    /**
    * Number of blocked emails for the date
    */
    'blocked': number;
    /**
    * Number of invalid emails for the date
    */
    'invalid': number;
    /**
    * Number of unsubscribed emails for the date
    */
    'unsubscribed': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "opens",
            "baseName": "opens",
            "type": "number"
        },
        {
            "name": "uniqueOpens",
            "baseName": "uniqueOpens",
            "type": "number"
        },
        {
            "name": "spamReports",
            "baseName": "spamReports",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "invalid",
            "baseName": "invalid",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetReportsReports.attributeTypeMap;
    }
}

export class GetSendersList {
    /**
    * List of the senders available in your account
    */
    'senders': Array<GetSendersListSenders>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "senders",
            "baseName": "senders",
            "type": "Array<GetSendersListSenders>"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersList.attributeTypeMap;
    }
}

export class GetSendersListIps {
    /**
    * Dedicated IP available in your account
    */
    'ip': string;
    /**
    * Domain of the IP
    */
    'domain': string;
    /**
    * Weight of the IP for this sender
    */
    'weight': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersListIps.attributeTypeMap;
    }
}

export class GetSendersListSenders {
    /**
    * Id of the sender
    */
    'id': number;
    /**
    * From Name associated to the sender
    */
    'name': string;
    /**
    * From Email associated to the sender
    */
    'email': string;
    /**
    * Status of sender (true=activated, false=deactivated)
    */
    'active': boolean;
    /**
    * List of dedicated IP(s) available in the account. This data is displayed only for dedicated IPs
    */
    'ips': Array<GetSendersListIps>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetSendersListIps>"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersListSenders.attributeTypeMap;
    }
}

export class GetSmsCampaignOverview {
    /**
    * ID of the SMS Campaign
    */
    'id': number;
    /**
    * Name of the SMS Campaign
    */
    'name': string;
    /**
    * Status of the SMS Campaign
    */
    'status': GetSmsCampaignOverview.StatusEnum;
    /**
    * Content of the SMS Campaign
    */
    'content': string;
    /**
    * UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
    */
    'scheduledAt': Date;
    /**
    * Sender of the SMS Campaign
    */
    'sender': string;
    /**
    * Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetSmsCampaignOverview.StatusEnum"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaignOverview.attributeTypeMap;
    }
}

export namespace GetSmsCampaignOverview {
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'inProcess'
    }
}
export class GetSmsCampaignStats {
    /**
    * Number of delivered SMS
    */
    'delivered': number;
    /**
    * Number of sent SMS
    */
    'sent': number;
    /**
    * Number of processing SMS
    */
    'processing': number;
    /**
    * Number of softbounced SMS
    */
    'softBounces': number;
    /**
    * Number of hardbounced SMS
    */
    'hardBounces': number;
    /**
    * Number of unsubscription SMS
    */
    'unsubscriptions': number;
    /**
    * Number of replies to the SMS
    */
    'answered': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "sent",
            "baseName": "sent",
            "type": "number"
        },
        {
            "name": "processing",
            "baseName": "processing",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "number"
        },
        {
            "name": "answered",
            "baseName": "answered",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaignStats.attributeTypeMap;
    }
}

export class GetSmsCampaigns {
    'campaigns': Array<any>;
    /**
    * Number of SMS campaigns retrieved
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaigns.attributeTypeMap;
    }
}

export class GetSmsEventReport {
    'events': Array<GetSmsEventReportEvents>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetSmsEventReportEvents>"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsEventReport.attributeTypeMap;
    }
}

export class GetSmsEventReportEvents {
    /**
    * Phone number which has generated the event
    */
    'phoneNumber': string;
    /**
    * UTC date-time on which the event has been generated
    */
    'date': Date;
    /**
    * Message ID which generated the event
    */
    'messageId': string;
    /**
    * Event which occurred
    */
    'event': GetSmsEventReportEvents.EventEnum;
    /**
    * Reason of bounce (only available if the event is hardbounce or softbounce)
    */
    'reason': string;
    'reply': string;
    /**
    * Tag of the SMS which generated the event
    */
    'tag': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "GetSmsEventReportEvents.EventEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "reply",
            "baseName": "reply",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsEventReportEvents.attributeTypeMap;
    }
}

export namespace GetSmsEventReportEvents {
    export enum EventEnum {
        Bounces = <any> 'bounces',
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces',
        Delivered = <any> 'delivered',
        Sent = <any> 'sent',
        Accepted = <any> 'accepted',
        Unsubscription = <any> 'unsubscription',
        Replies = <any> 'replies',
        Blocked = <any> 'blocked'
    }
}
export class GetSmtpTemplateOverview {
    /**
    * ID of the template
    */
    'id': number;
    /**
    * Name of the template
    */
    'name': string;
    /**
    * Subject of the template
    */
    'subject': string;
    /**
    * Status of template (true=active, false=inactive)
    */
    'isActive': boolean;
    /**
    * Status of test sending for the template (true=test email has been sent, false=test email has not been sent)
    */
    'testSent': boolean;
    'sender': GetSmtpTemplateOverviewSender;
    /**
    * Email defined as the \"Reply to\" for the template
    */
    'replyTo': string;
    /**
    * Customisation of the \"to\" field for the template
    */
    'toField': string;
    /**
    * Tag of the template
    */
    'tag': string;
    /**
    * HTML content of the template
    */
    'htmlContent': string;
    /**
    * Creation UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * Last modification UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "testSent",
            "baseName": "testSent",
            "type": "boolean"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "GetSmtpTemplateOverviewSender"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplateOverview.attributeTypeMap;
    }
}

export class GetSmtpTemplateOverviewSender {
    /**
    * From email for the template
    */
    'name': string;
    /**
    * From email for the template
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplateOverviewSender.attributeTypeMap;
    }
}

export class GetSmtpTemplates {
    /**
    * Count of transactional email templates
    */
    'count': number;
    'templates': Array<GetSmtpTemplateOverview>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "templates",
            "baseName": "templates",
            "type": "Array<GetSmtpTemplateOverview>"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplates.attributeTypeMap;
    }
}

export class GetSsoToken {
    /**
    * Session token. It will remain valid for a short period of time only.
    */
    'token': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSsoToken.attributeTypeMap;
    }
}

export class GetStatsByDomain extends null<String, GetCampaignStats> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetStatsByDomain.attributeTypeMap);
    }
}

export class GetTransacAggregatedSmsReport {
    /**
    * Time frame of the report
    */
    'range': string;
    /**
    * Number of requests for the timeframe
    */
    'requests': number;
    /**
    * Number of delivered SMS for the timeframe
    */
    'delivered': number;
    /**
    * Number of hardbounces for the timeframe
    */
    'hardBounces': number;
    /**
    * Number of softbounces for the timeframe
    */
    'softBounces': number;
    /**
    * Number of blocked contact for the timeframe
    */
    'blocked': number;
    /**
    * Number of unsubscription for the timeframe
    */
    'unsubscribed': number;
    /**
    * Number of answered SMS for the timeframe
    */
    'replied': number;
    /**
    * Number of accepted for the timeframe
    */
    'accepted': number;
    /**
    * Number of rejected for the timeframe
    */
    'rejected': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "range",
            "baseName": "range",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        },
        {
            "name": "replied",
            "baseName": "replied",
            "type": "number"
        },
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "number"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacAggregatedSmsReport.attributeTypeMap;
    }
}

export class GetTransacEmailContent {
    /**
    * Email address to which transactional email has been sent
    */
    'email': string;
    /**
    * Subject of the sent email
    */
    'subject': string;
    /**
    * Id of the template
    */
    'templateId': number;
    /**
    * Date on which transactional email was sent
    */
    'date': Date;
    /**
    * Series of events which occurred on the transactional email
    */
    'events': Array<GetTransacEmailContentEvents>;
    /**
    * Actual content of the transactional email that has been sent
    */
    'body': string;
    /**
    * Count of the attachments that were sent in the email
    */
    'attachmentCount': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetTransacEmailContentEvents>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "attachmentCount",
            "baseName": "attachmentCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailContent.attributeTypeMap;
    }
}

export class GetTransacEmailContentEvents {
    /**
    * Name of the event that occurred on the sent email
    */
    'name': string;
    /**
    * Time at which the event occurred
    */
    'time': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailContentEvents.attributeTypeMap;
    }
}

export class GetTransacEmailsList {
    'transactionalEmails': Array<GetTransacEmailsListTransactionalEmails>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionalEmails",
            "baseName": "transactionalEmails",
            "type": "Array<GetTransacEmailsListTransactionalEmails>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailsList.attributeTypeMap;
    }
}

export class GetTransacEmailsListTransactionalEmails {
    /**
    * Email address to which transactional email has been sent
    */
    'email': string;
    /**
    * Subject of the sent email
    */
    'subject': string;
    /**
    * Id of the template
    */
    'templateId': number;
    /**
    * Message Id of the sent email
    */
    'messageId': string;
    /**
    * Unique id of the email sent to a particular contact
    */
    'uuid': string;
    /**
    * Date on which transactional email was sent
    */
    'date': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailsListTransactionalEmails.attributeTypeMap;
    }
}

export class GetTransacSmsReport {
    'reports': Array<GetTransacSmsReportReports>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reports",
            "baseName": "reports",
            "type": "Array<GetTransacSmsReportReports>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacSmsReport.attributeTypeMap;
    }
}

export class GetTransacSmsReportReports {
    /**
    * Date for which statistics are retrieved
    */
    'date': string;
    /**
    * Number of requests for the date
    */
    'requests': number;
    /**
    * Number of delivered SMS for the date
    */
    'delivered': number;
    /**
    * Number of hardbounces for the date
    */
    'hardBounces': number;
    /**
    * Number of softbounces for the date
    */
    'softBounces': number;
    /**
    * Number of blocked contact for the date
    */
    'blocked': number;
    /**
    * Number of unsubscription for the date
    */
    'unsubscribed': number;
    /**
    * Number of answered SMS for the date
    */
    'replied': number;
    /**
    * Number of accepted for the date
    */
    'accepted': number;
    /**
    * Number of rejected for the date
    */
    'rejected': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        },
        {
            "name": "replied",
            "baseName": "replied",
            "type": "number"
        },
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "number"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacSmsReportReports.attributeTypeMap;
    }
}

export class GetWebhook {
    /**
    * URL of the webhook
    */
    'url': string;
    /**
    * ID of the webhook
    */
    'id': number;
    /**
    * Description of the webhook
    */
    'description': string;
    'events': Array<string>;
    /**
    * Type of webhook (marketing or transac)
    */
    'type': GetWebhook.TypeEnum;
    /**
    * Creation UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * Last modification UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetWebhook.TypeEnum"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetWebhook.attributeTypeMap;
    }
}

export namespace GetWebhook {
    export enum TypeEnum {
        Marketing = <any> 'marketing',
        Transac = <any> 'transac'
    }
}
export class GetWebhooks {
    'webhooks': Array<any>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhooks",
            "baseName": "webhooks",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return GetWebhooks.attributeTypeMap;
    }
}

export class ManageIp {
    /**
    * Dedicated ID
    */
    'ip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ManageIp.attributeTypeMap;
    }
}

export class PostContactInfo {
    'contacts': PostContactInfoContacts;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "PostContactInfoContacts"
        }    ];

    static getAttributeTypeMap() {
        return PostContactInfo.attributeTypeMap;
    }
}

export class PostContactInfoContacts {
    'success': Array<string>;
    'failure': Array<string>;
    /**
    * Displays the count of total number of contacts removed from list when user opts for \"all\" option.
    */
    'total': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "Array<string>"
        },
        {
            "name": "failure",
            "baseName": "failure",
            "type": "Array<string>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostContactInfoContacts.attributeTypeMap;
    }
}

export class PostSendFailed {
    /**
    * Response code
    */
    'code': number;
    /**
    * Response message
    */
    'message': string;
    'unexistingEmails': Array<string>;
    'withoutListEmails': Array<string>;
    'blackListedEmails': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "unexistingEmails",
            "baseName": "unexistingEmails",
            "type": "Array<string>"
        },
        {
            "name": "withoutListEmails",
            "baseName": "withoutListEmails",
            "type": "Array<string>"
        },
        {
            "name": "blackListedEmails",
            "baseName": "blackListedEmails",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PostSendFailed.attributeTypeMap;
    }
}

export class PostSendSmsTestFailed {
    /**
    * Response code
    */
    'code': number;
    /**
    * Response message
    */
    'message': string;
    'unexistingSms': Array<string>;
    'withoutListSms': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "unexistingSms",
            "baseName": "unexistingSms",
            "type": "Array<string>"
        },
        {
            "name": "withoutListSms",
            "baseName": "withoutListSms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PostSendSmsTestFailed.attributeTypeMap;
    }
}

export class RemainingCreditModel {
    'child': RemainingCreditModelChild;
    'reseller': RemainingCreditModelReseller;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "child",
            "baseName": "child",
            "type": "RemainingCreditModelChild"
        },
        {
            "name": "reseller",
            "baseName": "reseller",
            "type": "RemainingCreditModelReseller"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModel.attributeTypeMap;
    }
}

/**
* Credits remaining for child account
*/
export class RemainingCreditModelChild {
    /**
    * SMS Credits remaining for child account
    */
    'sms': number;
    /**
    * Email Credits remaining for child account
    */
    'email': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModelChild.attributeTypeMap;
    }
}

export class RemainingCreditModelReseller {
    /**
    * SMS Credits remaining for reseller account
    */
    'sms': number;
    /**
    * Email Credits remaining for reseller account
    */
    'email': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModelReseller.attributeTypeMap;
    }
}

export class RemoveContactFromList {
    /**
    * Required if 'all' is false. Emails to remove from a list
    */
    'emails': Array<string>;
    /**
    * Required if 'emails' is empty. Remove all existing contacts from a list
    */
    'all': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        },
        {
            "name": "all",
            "baseName": "all",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RemoveContactFromList.attributeTypeMap;
    }
}

export class RemoveCredits {
    /**
    * Required if email credits are empty. SMS credits to be removed from the child account
    */
    'sms': number;
    /**
    * Required if sms credits are empty. Email credits to be removed from the child account
    */
    'email': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemoveCredits.attributeTypeMap;
    }
}

export class RequestContactExport {
    /**
    * List of all the attributes that you want to export. These attributes must be present in your contact database. For example, ['fname', 'lname', 'email'].
    */
    'exportAttributes': Array<string>;
    /**
    * Set the filter for the contacts to be exported. For example, {'blacklisted':true} will export all the blacklisted contacts.
    */
    'contactFilter': any;
    /**
    * Webhook that will be called once the export process is finished
    */
    'notifyUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exportAttributes",
            "baseName": "exportAttributes",
            "type": "Array<string>"
        },
        {
            "name": "contactFilter",
            "baseName": "contactFilter",
            "type": "any"
        },
        {
            "name": "notifyUrl",
            "baseName": "notifyUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactExport.attributeTypeMap;
    }
}

export class RequestContactImport {
    /**
    * Mandatory if fileBody is not defined. URL of the file to be imported (no local file). Possible file formats: .txt, .csv
    */
    'fileUrl': string;
    /**
    * Mandatory if fileUrl is not defined. CSV content to be imported. Use semicolon to separate multiple attributes
    */
    'fileBody': string;
    /**
    * Mandatory if newList is not defined. Ids of the lists in which the contacts shall be imported. For example, [2, 4, 7].
    */
    'listIds': Array<number>;
    /**
    * URL that will be called once the export process is finished
    */
    'notifyUrl': string;
    'newList': RequestContactImportNewList;
    /**
    * To blacklist all the contacts for email
    */
    'emailBlacklist': boolean;
    /**
    * To blacklist all the contacts for sms
    */
    'smsBlacklist': boolean;
    /**
    * To facilitate the choice to update the existing contacts
    */
    'updateExistingContacts': boolean;
    /**
    * To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in SendinBlue, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( only available if `updateExistingContacts` set to true )
    */
    'emptyContactsAttributes': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileUrl",
            "baseName": "fileUrl",
            "type": "string"
        },
        {
            "name": "fileBody",
            "baseName": "fileBody",
            "type": "string"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "notifyUrl",
            "baseName": "notifyUrl",
            "type": "string"
        },
        {
            "name": "newList",
            "baseName": "newList",
            "type": "RequestContactImportNewList"
        },
        {
            "name": "emailBlacklist",
            "baseName": "emailBlacklist",
            "type": "boolean"
        },
        {
            "name": "smsBlacklist",
            "baseName": "smsBlacklist",
            "type": "boolean"
        },
        {
            "name": "updateExistingContacts",
            "baseName": "updateExistingContacts",
            "type": "boolean"
        },
        {
            "name": "emptyContactsAttributes",
            "baseName": "emptyContactsAttributes",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactImport.attributeTypeMap;
    }
}

/**
* To create a new list and import the contacts into it, pass the listName and an optional folderId.
*/
export class RequestContactImportNewList {
    /**
    * List with listName will be created first and users will be imported in it (Mandatory if listIds is empty).
    */
    'listName': string;
    /**
    * Id of the folder where this new list shall be created (Mandatory if listName is not empty).
    */
    'folderId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listName",
            "baseName": "listName",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactImportNewList.attributeTypeMap;
    }
}

export class RequestSmsRecipientExport {
    /**
    * URL that will be called once the export process is finished
    */
    'notifyURL': string;
    /**
    * Filter the recipients based on how they interacted with the campaign
    */
    'recipientsType': RequestSmsRecipientExport.RecipientsTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifyURL",
            "baseName": "notifyURL",
            "type": "string"
        },
        {
            "name": "recipientsType",
            "baseName": "recipientsType",
            "type": "RequestSmsRecipientExport.RecipientsTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return RequestSmsRecipientExport.attributeTypeMap;
    }
}

export namespace RequestSmsRecipientExport {
    export enum RecipientsTypeEnum {
        All = <any> 'all',
        Delivered = <any> 'delivered',
        Answered = <any> 'answered',
        SoftBounces = <any> 'softBounces',
        HardBounces = <any> 'hardBounces',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class SendEmail {
    /**
    * List of the email addresses of the recipients. For example, ['abc@example.com', 'asd@example.com'].
    */
    'emailTo': Array<string>;
    /**
    * List of the email addresses of the recipients in bcc
    */
    'emailBcc': Array<string>;
    /**
    * List of the email addresses of the recipients in cc
    */
    'emailCc': Array<string>;
    /**
    * Email address which shall be used by campaign recipients to reply back
    */
    'replyTo': string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl': string;
    /**
    * Pass the list of content (base64 encoded) and name of the attachment. For example, [{'content':'base64 encoded content 1', 'name':'attcahment1'}, {'content':'base64 encoded content 2', 'name':'attcahment2'}].
    */
    'attachment': Array<SendEmailAttachment>;
    /**
    * Pass the set of headers that shall be sent along the mail headers in the original email. 'sender.ip' header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. For example, {'Content-Type':'text/html', 'charset':'iso-8859-1', 'sender.ip':'1.2.3.4'}
    */
    'headers': any;
    /**
    * Pass the set of attributes to customize the template. For example, {'FNAME':'Joe', 'LNAME':'Doe'}
    */
    'attributes': any;
    /**
    * Tag your emails to find them more easily
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailTo",
            "baseName": "emailTo",
            "type": "Array<string>"
        },
        {
            "name": "emailBcc",
            "baseName": "emailBcc",
            "type": "Array<string>"
        },
        {
            "name": "emailCc",
            "baseName": "emailCc",
            "type": "Array<string>"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Array<SendEmailAttachment>"
        },
        {
            "name": "headers",
            "baseName": "headers",
            "type": "any"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendEmail.attributeTypeMap;
    }
}

export class SendEmailAttachment {
    /**
    * Base64 encoded chunk data of the attachment generated on the fly
    */
    'content': string;
    /**
    * Required for content. Name of the attachment
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendEmailAttachment.attributeTypeMap;
    }
}

export class SendReport {
    /**
    * Language of email content for campaign report sending.
    */
    'language': SendReport.LanguageEnum;
    'email': SendReportEmail;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "language",
            "baseName": "language",
            "type": "SendReport.LanguageEnum"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "SendReportEmail"
        }    ];

    static getAttributeTypeMap() {
        return SendReport.attributeTypeMap;
    }
}

export namespace SendReport {
    export enum LanguageEnum {
        Fr = <any> 'fr',
        Es = <any> 'es',
        Pt = <any> 'pt',
        It = <any> 'it',
        De = <any> 'de',
        En = <any> 'en'
    }
}
/**
* Email sending credentials including subject, body, to, cc etc.
*/
export class SendReportEmail {
    /**
    * Subject of the email message
    */
    'subject': string;
    /**
    * Email addresses of the recipients
    */
    'to': Array<string>;
    /**
    * Type of the message body
    */
    'contentType': SendReportEmail.ContentTypeEnum;
    /**
    * Email addresses of the recipients in bcc
    */
    'bcc': Array<string>;
    /**
    * Email addresses of the recipients in cc
    */
    'cc': Array<string>;
    /**
    * Body of the email message
    */
    'body': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<string>"
        },
        {
            "name": "contentType",
            "baseName": "contentType",
            "type": "SendReportEmail.ContentTypeEnum"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<string>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<string>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendReportEmail.attributeTypeMap;
    }
}

export namespace SendReportEmail {
    export enum ContentTypeEnum {
        Text = <any> 'text',
        Html = <any> 'html'
    }
}
export class SendSms {
    'reference': string;
    'messageId': number;
    /**
    * Count of SMS's to send multiple text messages
    */
    'smsCount': number;
    /**
    * SMS credits used per text message
    */
    'usedCredits': number;
    /**
    * Remaining SMS credits of the user
    */
    'remainingCredits': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "number"
        },
        {
            "name": "smsCount",
            "baseName": "smsCount",
            "type": "number"
        },
        {
            "name": "usedCredits",
            "baseName": "usedCredits",
            "type": "number"
        },
        {
            "name": "remainingCredits",
            "baseName": "remainingCredits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SendSms.attributeTypeMap;
    }
}

export class SendSmtpEmail {
    'sender': SendSmtpEmailSender;
    /**
    * List of email addresses and names (optional) of the recipients. For example, [{'name':'Jimmy', 'email':'jimmy98@example.com'}, {'name':'Joe', 'email':'joe@example.com'}]
    */
    'to': Array<SendSmtpEmailTo>;
    /**
    * List of email addresses and names (optional) of the recipients in bcc
    */
    'bcc': Array<SendSmtpEmailBcc>;
    /**
    * List of email addresses and names (optional) of the recipients in cc
    */
    'cc': Array<SendSmtpEmailCc>;
    /**
    * HTML body of the message ( Mandatory if 'templateId' is not passed, ignored if 'templateId' is passed )
    */
    'htmlContent': string;
    /**
    * Plain Text body of the message ( Ignored if 'templateId' is passed )
    */
    'textContent': string;
    /**
    * Subject of the message. Mandatory if 'templateId' is not passed
    */
    'subject': string;
    'replyTo': SendSmtpEmailReplyTo;
    /**
    * Pass the absolute URL (no local file) or the base64 content of the attachment along with the attachment name (Mandatory if attachment content is passed). For example, `[{\"url\":\"https://attachment.domain.com/myAttachmentFromUrl.jpg\", \"name\":\"My attachment 1\"}, {\"content\":\"base64 exmaple content\", \"name\":\"My attachment 2\"}]`. Allowed extensions for attachment file: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg and wmv ( If 'templateId' is passed and is in New Template Language format then only attachment url is accepted. If template is in Old template Language format, then 'attachment' is ignored )
    */
    'attachment': Array<SendSmtpEmailAttachment>;
    /**
    * Pass the set of custom headers (not the standard headers) that shall be sent along the mail headers in the original email. 'sender.ip' header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. For example, `{\"sender.ip\":\"1.2.3.4\", \"X-Mailin-custom\":\"some_custom_header\"}`.
    */
    'headers': any;
    /**
    * Id of the template
    */
    'templateId': number;
    /**
    * Pass the set of attributes to customize the template. For example, {'FNAME':'Joe', 'LNAME':'Doe'}. It's considered only if template is in New Template Language format.
    */
    'params': any;
    /**
    * Tag your emails to find them more easily
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sender",
            "baseName": "sender",
            "type": "SendSmtpEmailSender"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<SendSmtpEmailTo>"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<SendSmtpEmailBcc>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<SendSmtpEmailCc>"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "textContent",
            "baseName": "textContent",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "SendSmtpEmailReplyTo"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Array<SendSmtpEmailAttachment>"
        },
        {
            "name": "headers",
            "baseName": "headers",
            "type": "any"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmail.attributeTypeMap;
    }
}

export class SendSmtpEmailAttachment {
    /**
    * Absolute url of the attachment (no local file).
    */
    'url': string;
    /**
    * Base64 encoded chunk data of the attachment generated on the fly
    */
    'content': string;
    /**
    * Required if content is passed. Name of the attachment
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailAttachment.attributeTypeMap;
    }
}

export class SendSmtpEmailBcc {
    /**
    * Email address of the recipient in bcc
    */
    'email': string;
    /**
    * Name of the recipient in bcc
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailBcc.attributeTypeMap;
    }
}

export class SendSmtpEmailCc {
    /**
    * Email address of the recipient in cc
    */
    'email': string;
    /**
    * Name of the recipient in cc
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailCc.attributeTypeMap;
    }
}

/**
* Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {'email':'ann6533@example.com', 'name':'Ann'}.
*/
export class SendSmtpEmailReplyTo {
    /**
    * Email address in reply to
    */
    'email': string;
    /**
    * Name in reply to
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailReplyTo.attributeTypeMap;
    }
}

/**
* Mandatory if 'templateId' is not passed. Pass name (optional) and email of sender from which emails will be sent. For example, {'name':'Mary from MyShop', 'email':'no-reply@myshop.com'}
*/
export class SendSmtpEmailSender {
    /**
    * Name of the sender from which the emails will be sent
    */
    'name': string;
    /**
    * Email of the sender from which the emails will be sent
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailSender.attributeTypeMap;
    }
}

export class SendSmtpEmailTo {
    /**
    * Email address of the recipient
    */
    'email': string;
    /**
    * Name of the recipient
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailTo.attributeTypeMap;
    }
}

export class SendTemplateEmail {
    /**
    * Message ID of the template Email sent
    */
    'messageId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTemplateEmail.attributeTypeMap;
    }
}

export class SendTestEmail {
    /**
    * List of the email addresses of the recipients whom you wish to send the test mail. If left empty, the test mail will be sent to your entire test list.
    */
    'emailTo': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailTo",
            "baseName": "emailTo",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendTestEmail.attributeTypeMap;
    }
}

export class SendTestSms {
    /**
    * Mobile number of the recipient with the country code. This number must belong to one of your contacts in SendinBlue account and must not be blacklisted
    */
    'phoneNumber': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTestSms.attributeTypeMap;
    }
}

export class SendTransacSms {
    /**
    * Name of the sender. Only alphanumeric characters. No more than 11 characters
    */
    'sender': string;
    /**
    * Mobile number to send SMS with the country code
    */
    'recipient': string;
    /**
    * Content of the message. If more than 160 characters long, will be sent as multiple text messages
    */
    'content': string;
    /**
    * Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.
    */
    'type': SendTransacSms.TypeEnum;
    /**
    * Tag of the message
    */
    'tag': string;
    /**
    * Webhook to call for each event triggered by the message (delivered etc.)
    */
    'webUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "SendTransacSms.TypeEnum"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "webUrl",
            "baseName": "webUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTransacSms.attributeTypeMap;
    }
}

export namespace SendTransacSms {
    export enum TypeEnum {
        Transactional = <any> 'transactional',
        Marketing = <any> 'marketing'
    }
}
export class UpdateAttribute {
    /**
    * Value of the attribute to update. Use only if the attribute's category is 'calculated' or 'global'
    */
    'value': string;
    /**
    * List of the values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{'value':1, 'label':'male'}, {'value':2, 'label':'female'}]
    */
    'enumeration': Array<UpdateAttributeEnumeration>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<UpdateAttributeEnumeration>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAttribute.attributeTypeMap;
    }
}

export class UpdateAttributeEnumeration {
    /**
    * Id of the value
    */
    'value': number;
    /**
    * Label of the value
    */
    'label': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAttributeEnumeration.attributeTypeMap;
    }
}

/**
* Status of the campaign
*/
export class UpdateCampaignStatus {
    /**
    * Note:- replicateTemplate status will be available only for template type campaigns.
    */
    'status': UpdateCampaignStatus.StatusEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "UpdateCampaignStatus.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCampaignStatus.attributeTypeMap;
    }
}

export namespace UpdateCampaignStatus {
    export enum StatusEnum {
        Suspended = <any> 'suspended',
        Archive = <any> 'archive',
        Darchive = <any> 'darchive',
        Sent = <any> 'sent',
        Queued = <any> 'queued',
        Replicate = <any> 'replicate',
        ReplicateTemplate = <any> 'replicateTemplate',
        Draft = <any> 'draft'
    }
}
export class UpdateChild {
    /**
    * New Email address to update the child account
    */
    'email': string;
    /**
    * New First name to use to update the child account
    */
    'firstName': string;
    /**
    * New Last name to use to update the child account
    */
    'lastName': string;
    /**
    * New Company name to use to update the child account
    */
    'companyName': string;
    /**
    * New password for the child account to login
    */
    'password': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChild.attributeTypeMap;
    }
}

export class UpdateChildAccountStatus {
    /**
    * Status of Transactional Email Platform activation for your account (true=enabled, false=disabled)
    */
    'transactionalEmail': boolean;
    /**
    * Status of Transactional SMS Platform activation for your account (true=enabled, false=disabled)
    */
    'transactionalSms': boolean;
    /**
    * Status of Marketing Automation Platform activation for your account (true=enabled, false=disabled)
    */
    'marketingAutomation': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionalEmail",
            "baseName": "transactionalEmail",
            "type": "boolean"
        },
        {
            "name": "transactionalSms",
            "baseName": "transactionalSms",
            "type": "boolean"
        },
        {
            "name": "marketingAutomation",
            "baseName": "marketingAutomation",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChildAccountStatus.attributeTypeMap;
    }
}

export class UpdateChildDomain {
    /**
    * Value for the sender domain that will replace the existing domain
    */
    'domain': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChildDomain.attributeTypeMap;
    }
}

export class UpdateContact {
    /**
    * Pass the set of attributes to be updated. These attributes must be present in your account. To update existing email address of a contact with the new one please pass EMAIL in attribtes. For eg. { 'EMAIL':'newemail@domain.com', 'FNAME':'Ellie', 'LNAME':'Roger'}
    */
    'attributes': any;
    /**
    * Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)
    */
    'emailBlacklisted': boolean;
    /**
    * Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)
    */
    'smsBlacklisted': boolean;
    /**
    * Ids of the lists to add the contact to
    */
    'listIds': Array<number>;
    /**
    * Ids of the lists to remove the contact from
    */
    'unlinkListIds': Array<number>;
    /**
    * transactional email forbidden sender for contact. Use only for email Contact
    */
    'smtpBlacklistSender': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "unlinkListIds",
            "baseName": "unlinkListIds",
            "type": "Array<number>"
        },
        {
            "name": "smtpBlacklistSender",
            "baseName": "smtpBlacklistSender",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateContact.attributeTypeMap;
    }
}

export class UpdateEmailCampaign {
    /**
    * Tag of the campaign
    */
    'tag': string;
    'sender': UpdateEmailCampaignSender;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Body of the message (HTML version). REQUIRED if htmlUrl is empty
    */
    'htmlContent': string;
    /**
    * Url which contents the body of the email message. REQUIRED if htmlContent is empty
    */
    'htmlUrl': string;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
    */
    'scheduledAt': Date;
    /**
    * Subject of the campaign
    */
    'subject': string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo': string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField': string;
    'recipients': UpdateEmailCampaignRecipients;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl': string;
    /**
    * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than 4MB with images embedded in the email. Campaigns with the images embedded in the email must be sent to less than 5000 contacts.
    */
    'inlineImageActivation': boolean;
    /**
    * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
    */
    'mirrorActive': boolean;
    /**
    * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    */
    'recurring': boolean;
    /**
    * Footer of the email campaign
    */
    'footer': string;
    /**
    * Header of the email campaign
    */
    'header': string;
    /**
    * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
    */
    'utmCampaign': string;
    /**
    * Pass the set of attributes to customize the type 'classic' campaign. For example, {'FNAME':'Joe', 'LNAME':'Doe'}. The 'params' field will get updated, only if the campaign is in New Template Language, else ignored. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
    */
    'params': any;
    /**
    * Set this to true if you want to send your campaign at best time. Note:- if true, warmup ip will be disabled.
    */
    'sendAtBestTime': boolean;
    /**
    * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered if abTesting is set to true. 'subject' if passed is ignored.  Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
    */
    'abTesting': boolean;
    /**
    * Subject A of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectA': string;
    /**
    * Subject B of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectB': string;
    /**
    * Add the size of your test groups. Considered if abTesting = true. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
    */
    'splitRule': number;
    /**
    * Choose the metrics that will determinate the winning version. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed or alreday exist in record
    */
    'winnerCriteria': UpdateEmailCampaign.WinnerCriteriaEnum;
    /**
    * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed or alreday exist in record
    */
    'winnerDelay': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "UpdateEmailCampaignSender"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "UpdateEmailCampaignRecipients"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "recurring",
            "baseName": "recurring",
            "type": "boolean"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "UpdateEmailCampaign.WinnerCriteriaEnum"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaign.attributeTypeMap;
    }
}

export namespace UpdateEmailCampaign {
    export enum WinnerCriteriaEnum {
        Open = <any> 'open',
        Click = <any> 'click'
    }
}
/**
* List ids to include/exclude from campaign
*/
export class UpdateEmailCampaignRecipients {
    /**
    * List ids which have to be excluded from a campaign
    */
    'exclusionListIds': Array<number>;
    /**
    * Lists Ids to send the campaign to. REQUIRED if already not present in campaign and scheduledAt is not empty
    */
    'listIds': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaignRecipients.attributeTypeMap;
    }
}

/**
* Sender details including email and/or name. For example {'name':'xyz' , 'email':'example@abc.com'}
*/
export class UpdateEmailCampaignSender {
    /**
    * Sender Name from which the campaign emails are sent
    */
    'name': string;
    /**
    * Sender email from which the campaign emails are sent
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaignSender.attributeTypeMap;
    }
}

export class UpdateList {
    /**
    * Name of the list. Either of the two parameters (name, folderId) can be updated at a time.
    */
    'name': string;
    /**
    * Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.
    */
    'folderId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateList.attributeTypeMap;
    }
}

export class UpdateSender {
    /**
    * From Name to update the sender
    */
    'name': string;
    /**
    * From Email to update the sender
    */
    'email': string;
    /**
    * Only in case of dedicated IP, IPs to associate to the sender. If passed, will replace all the existing IPs.
    */
    'ips': Array<CreateSenderIps>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<CreateSenderIps>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSender.attributeTypeMap;
    }
}

export class UpdateSmsCampaign {
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Name of the sender. The number of characters is limited to 11
    */
    'sender': string;
    /**
    * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
    */
    'content': string;
    'recipients': CreateSmsCampaignRecipients;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
    */
    'scheduledAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateSmsCampaignRecipients"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmsCampaign.attributeTypeMap;
    }
}

export class UpdateSmtpTemplate {
    /**
    * Tag of the template
    */
    'tag': string;
    'sender': UpdateSmtpTemplateSender;
    /**
    * Name of the template
    */
    'templateName': string;
    /**
    * Required if htmlUrl is empty. Body of the message (HTML must have more than 10 characters)
    */
    'htmlContent': string;
    /**
    * Required if htmlContent is empty. URL to the body of the email (HTML)
    */
    'htmlUrl': string;
    /**
    * Subject of the email
    */
    'subject': string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo': string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField': string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl': string;
    /**
    * Status of the template. isActive = false means template is inactive, isActive = true means template is active
    */
    'isActive': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "UpdateSmtpTemplateSender"
        },
        {
            "name": "templateName",
            "baseName": "templateName",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmtpTemplate.attributeTypeMap;
    }
}

/**
* Sender details including email and/or name. For example {'name':'xyz' , 'email':'example@abc.com'}
*/
export class UpdateSmtpTemplateSender {
    /**
    * Name of the sender
    */
    'name': string;
    /**
    * Email of the sender
    */
    'email': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmtpTemplateSender.attributeTypeMap;
    }
}

export class UpdateWebhook {
    /**
    * URL of the webhook
    */
    'url': string;
    /**
    * Description of the webhook
    */
    'description': string;
    /**
    * Events triggering the webhook. Possible values for Transactional type webhook – request, delivered, hardBounce, softBounce, blocked, spam, invalid, deferred, click, opened, uniqueOpened and unsubscribed and possible values for Marketing type webhook – spam, opened, click, hardBounce, softBounce, unsubscribed, listAddition and delivered
    */
    'events': Array<UpdateWebhook.EventsEnum>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<UpdateWebhook.EventsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWebhook.attributeTypeMap;
    }
}

export namespace UpdateWebhook {
    export enum EventsEnum {
        HardBounce = <any> 'hardBounce',
        SoftBounce = <any> 'softBounce',
        Blocked = <any> 'blocked',
        Spam = <any> 'spam',
        Delivered = <any> 'delivered',
        Request = <any> 'request',
        Click = <any> 'click',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Opened = <any> 'opened',
        UniqueOpened = <any> 'uniqueOpened',
        Unsubscribed = <any> 'unsubscribed',
        ListAddition = <any> 'listAddition',
        ContactUpdated = <any> 'contactUpdated',
        ContactDeleted = <any> 'contactDeleted'
    }
}
export class GetChildInfo {
    /**
    * Login Email
    */
    'email': string;
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Name of the company
    */
    'companyName': string;
    'credits': GetChildInfoCredits;
    'statistics': GetChildInfoStatistics;
    /**
    * The encrypted password of child account
    */
    'password': string;
    /**
    * IP(s) associated to a child account user
    */
    'ips': Array<string>;
    'apiKeys': GetChildInfoApiKeys;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "credits",
            "baseName": "credits",
            "type": "GetChildInfoCredits"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetChildInfoStatistics"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<string>"
        },
        {
            "name": "apiKeys",
            "baseName": "apiKeys",
            "type": "GetChildInfoApiKeys"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfo.attributeTypeMap;
    }
}

export class GetExtendedCampaignOverview {
    /**
    * ID of the campaign
    */
    'id': number;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
    */
    'subject': string;
    /**
    * Type of campaign
    */
    'type': GetExtendedCampaignOverview.TypeEnum;
    /**
    * Status of the campaign
    */
    'status': GetExtendedCampaignOverview.StatusEnum;
    /**
    * UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'scheduledAt': Date;
    /**
    * Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.
    */
    'abTesting': boolean;
    /**
    * Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectA': string;
    /**
    * Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectB': string;
    /**
    * The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`
    */
    'splitRule': number;
    /**
    * Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerCriteria': string;
    /**
    * The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerDelay': number;
    /**
    * It is true if you have chosen to send your campaign at best time, otherwise it is false
    */
    'sendAtBestTime': boolean;
    /**
    * Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
    */
    'testSent': boolean;
    /**
    * Header of the campaign
    */
    'header': string;
    /**
    * Footer of the campaign
    */
    'footer': string;
    'sender': GetExtendedCampaignOverviewSender;
    /**
    * Email defined as the \"Reply to\" of the campaign
    */
    'replyTo': string;
    /**
    * Customisation of the \"to\" field of the campaign
    */
    'toField': string;
    /**
    * HTML content of the campaign
    */
    'htmlContent': string;
    /**
    * Link to share the campaign on social medias
    */
    'shareLink': string;
    /**
    * Tag of the campaign
    */
    'tag': string;
    /**
    * Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;
    /**
    * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email.
    */
    'inlineImageActivation': boolean;
    /**
    * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
    */
    'mirrorActive': boolean;
    /**
    * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    */
    'recurring': boolean;
    /**
    * Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if 'status' of the campaign is 'sent'
    */
    'sentDate': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetExtendedCampaignOverview.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetExtendedCampaignOverview.StatusEnum"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "string"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "testSent",
            "baseName": "testSent",
            "type": "boolean"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "GetExtendedCampaignOverviewSender"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "shareLink",
            "baseName": "shareLink",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "recurring",
            "baseName": "recurring",
            "type": "boolean"
        },
        {
            "name": "sentDate",
            "baseName": "sentDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignOverview.attributeTypeMap;
    }
}

export namespace GetExtendedCampaignOverview {
    export enum TypeEnum {
        Classic = <any> 'classic',
        Trigger = <any> 'trigger'
    }
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'in_process'
    }
}
export class GetExtendedClient {
    /**
    * Login Email
    */
    'email': string;
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Name of the company
    */
    'companyName': string;
    'address': GetExtendedClientAddress;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "GetExtendedClientAddress"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedClient.attributeTypeMap;
    }
}

export class GetExtendedContactDetails {
    /**
    * Email address of the contact for which you requested the details
    */
    'email': string;
    /**
    * ID of the contact for which you requested the details
    */
    'id': number;
    /**
    * Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
    */
    'emailBlacklisted': boolean;
    /**
    * Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
    */
    'smsBlacklisted': boolean;
    /**
    * Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;
    'listIds': Array<number>;
    'listUnsubscribed': Array<number>;
    /**
    * Set of attributes of the contact
    */
    'attributes': any;
    'statistics': GetExtendedContactDetailsStatistics;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "listUnsubscribed",
            "baseName": "listUnsubscribed",
            "type": "Array<number>"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetExtendedContactDetailsStatistics"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetails.attributeTypeMap;
    }
}

export class GetExtendedList {
    /**
    * ID of the list
    */
    'id': number;
    /**
    * Name of the list
    */
    'name': string;
    /**
    * Number of blacklisted contacts in the list
    */
    'totalBlacklisted': number;
    /**
    * Number of contacts in the list
    */
    'totalSubscribers': number;
    /**
    * ID of the folder
    */
    'folderId': number;
    /**
    * Creation UTC date-time of the list (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    'campaignStats': Array<GetExtendedListCampaignStats>;
    /**
    * Status telling if the list is dynamic or not (true=dynamic, false=not dynamic)
    */
    'dynamicList': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalBlacklisted",
            "baseName": "totalBlacklisted",
            "type": "number"
        },
        {
            "name": "totalSubscribers",
            "baseName": "totalSubscribers",
            "type": "number"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "campaignStats",
            "baseName": "campaignStats",
            "type": "Array<GetExtendedListCampaignStats>"
        },
        {
            "name": "dynamicList",
            "baseName": "dynamicList",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedList.attributeTypeMap;
    }
}

export class GetSmsCampaign {
    /**
    * ID of the SMS Campaign
    */
    'id': number;
    /**
    * Name of the SMS Campaign
    */
    'name': string;
    /**
    * Status of the SMS Campaign
    */
    'status': GetSmsCampaign.StatusEnum;
    /**
    * Content of the SMS Campaign
    */
    'content': string;
    /**
    * UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
    */
    'scheduledAt': Date;
    /**
    * Sender of the SMS Campaign
    */
    'sender': string;
    /**
    * Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;
    'recipients': any;
    'statistics': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetSmsCampaign.StatusEnum"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "any"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaign.attributeTypeMap;
    }
}

export namespace GetSmsCampaign {
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'inProcess'
    }
}
export class GetAccount {
    /**
    * Login Email
    */
    'email': string;
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Name of the company
    */
    'companyName': string;
    'address': GetExtendedClientAddress;
    /**
    * Information about your plans and credits
    */
    'plan': Array<GetAccountPlan>;
    'relay': GetAccountRelay;
    'marketingAutomation': GetAccountMarketingAutomation;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "GetExtendedClientAddress"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "Array<GetAccountPlan>"
        },
        {
            "name": "relay",
            "baseName": "relay",
            "type": "GetAccountRelay"
        },
        {
            "name": "marketingAutomation",
            "baseName": "marketingAutomation",
            "type": "GetAccountMarketingAutomation"
        }    ];

    static getAttributeTypeMap() {
        return GetAccount.attributeTypeMap;
    }
}

export class GetEmailCampaign {
    /**
    * ID of the campaign
    */
    'id': number;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
    */
    'subject': string;
    /**
    * Type of campaign
    */
    'type': GetEmailCampaign.TypeEnum;
    /**
    * Status of the campaign
    */
    'status': GetEmailCampaign.StatusEnum;
    /**
    * UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'scheduledAt': Date;
    /**
    * Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.
    */
    'abTesting': boolean;
    /**
    * Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectA': string;
    /**
    * Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectB': string;
    /**
    * The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`
    */
    'splitRule': number;
    /**
    * Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerCriteria': string;
    /**
    * The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerDelay': number;
    /**
    * It is true if you have chosen to send your campaign at best time, otherwise it is false
    */
    'sendAtBestTime': boolean;
    /**
    * Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
    */
    'testSent': boolean;
    /**
    * Header of the campaign
    */
    'header': string;
    /**
    * Footer of the campaign
    */
    'footer': string;
    'sender': GetExtendedCampaignOverviewSender;
    /**
    * Email defined as the \"Reply to\" of the campaign
    */
    'replyTo': string;
    /**
    * Customisation of the \"to\" field of the campaign
    */
    'toField': string;
    /**
    * HTML content of the campaign
    */
    'htmlContent': string;
    /**
    * Link to share the campaign on social medias
    */
    'shareLink': string;
    /**
    * Tag of the campaign
    */
    'tag': string;
    /**
    * Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': Date;
    /**
    * UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': Date;
    /**
    * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email.
    */
    'inlineImageActivation': boolean;
    /**
    * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
    */
    'mirrorActive': boolean;
    /**
    * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    */
    'recurring': boolean;
    /**
    * Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if 'status' of the campaign is 'sent'
    */
    'sentDate': Date;
    'recipients': any;
    'statistics': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetEmailCampaign.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetEmailCampaign.StatusEnum"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "Date"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "string"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "testSent",
            "baseName": "testSent",
            "type": "boolean"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "GetExtendedCampaignOverviewSender"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "shareLink",
            "baseName": "shareLink",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "Date"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "recurring",
            "baseName": "recurring",
            "type": "boolean"
        },
        {
            "name": "sentDate",
            "baseName": "sentDate",
            "type": "Date"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "any"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailCampaign.attributeTypeMap;
    }
}

export namespace GetEmailCampaign {
    export enum TypeEnum {
        Classic = <any> 'classic',
        Trigger = <any> 'trigger'
    }
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'in_process'
    }
}

let enumsMap: {[index: string]: any} = {
        "CreateAttribute.TypeEnum": CreateAttribute.TypeEnum,
        "CreateEmailCampaign.WinnerCriteriaEnum": CreateEmailCampaign.WinnerCriteriaEnum,
        "CreateWebhook.EventsEnum": CreateWebhook.EventsEnum,
        "CreateWebhook.TypeEnum": CreateWebhook.TypeEnum,
        "EmailExportRecipients.RecipientsTypeEnum": EmailExportRecipients.RecipientsTypeEnum,
        "ErrorModel.CodeEnum": ErrorModel.CodeEnum,
        "GetAccountPlan.TypeEnum": GetAccountPlan.TypeEnum,
        "GetAccountPlan.CreditsTypeEnum": GetAccountPlan.CreditsTypeEnum,
        "GetAttributesAttributes.CategoryEnum": GetAttributesAttributes.CategoryEnum,
        "GetAttributesAttributes.TypeEnum": GetAttributesAttributes.TypeEnum,
        "GetCampaignOverview.TypeEnum": GetCampaignOverview.TypeEnum,
        "GetCampaignOverview.StatusEnum": GetCampaignOverview.StatusEnum,
        "GetEmailEventReportEvents.EventEnum": GetEmailEventReportEvents.EventEnum,
        "GetProcess.StatusEnum": GetProcess.StatusEnum,
        "GetSmsCampaignOverview.StatusEnum": GetSmsCampaignOverview.StatusEnum,
        "GetSmsEventReportEvents.EventEnum": GetSmsEventReportEvents.EventEnum,
        "GetWebhook.TypeEnum": GetWebhook.TypeEnum,
        "RequestSmsRecipientExport.RecipientsTypeEnum": RequestSmsRecipientExport.RecipientsTypeEnum,
        "SendReport.LanguageEnum": SendReport.LanguageEnum,
        "SendReportEmail.ContentTypeEnum": SendReportEmail.ContentTypeEnum,
        "SendTransacSms.TypeEnum": SendTransacSms.TypeEnum,
        "UpdateCampaignStatus.StatusEnum": UpdateCampaignStatus.StatusEnum,
        "UpdateEmailCampaign.WinnerCriteriaEnum": UpdateEmailCampaign.WinnerCriteriaEnum,
        "UpdateWebhook.EventsEnum": UpdateWebhook.EventsEnum,
        "GetExtendedCampaignOverview.TypeEnum": GetExtendedCampaignOverview.TypeEnum,
        "GetExtendedCampaignOverview.StatusEnum": GetExtendedCampaignOverview.StatusEnum,
        "GetSmsCampaign.StatusEnum": GetSmsCampaign.StatusEnum,
        "GetEmailCampaign.TypeEnum": GetEmailCampaign.TypeEnum,
        "GetEmailCampaign.StatusEnum": GetEmailCampaign.StatusEnum,
}

let typeMap: {[index: string]: any} = {
    "AddChildDomain": AddChildDomain,
    "AddContactToList": AddContactToList,
    "AddCredits": AddCredits,
    "CreateAttribute": CreateAttribute,
    "CreateAttributeEnumeration": CreateAttributeEnumeration,
    "CreateChild": CreateChild,
    "CreateContact": CreateContact,
    "CreateEmailCampaign": CreateEmailCampaign,
    "CreateEmailCampaignRecipients": CreateEmailCampaignRecipients,
    "CreateEmailCampaignSender": CreateEmailCampaignSender,
    "CreateList": CreateList,
    "CreateModel": CreateModel,
    "CreateReseller": CreateReseller,
    "CreateSender": CreateSender,
    "CreateSenderIps": CreateSenderIps,
    "CreateSenderModel": CreateSenderModel,
    "CreateSmsCampaign": CreateSmsCampaign,
    "CreateSmsCampaignRecipients": CreateSmsCampaignRecipients,
    "CreateSmtpEmail": CreateSmtpEmail,
    "CreateSmtpTemplate": CreateSmtpTemplate,
    "CreateSmtpTemplateSender": CreateSmtpTemplateSender,
    "CreateUpdateContactModel": CreateUpdateContactModel,
    "CreateUpdateFolder": CreateUpdateFolder,
    "CreateWebhook": CreateWebhook,
    "CreatedProcessId": CreatedProcessId,
    "DeleteHardbounces": DeleteHardbounces,
    "EmailExportRecipients": EmailExportRecipients,
    "ErrorModel": ErrorModel,
    "GetAccountMarketingAutomation": GetAccountMarketingAutomation,
    "GetAccountPlan": GetAccountPlan,
    "GetAccountRelay": GetAccountRelay,
    "GetAccountRelayData": GetAccountRelayData,
    "GetAggregatedReport": GetAggregatedReport,
    "GetAttributes": GetAttributes,
    "GetAttributesAttributes": GetAttributesAttributes,
    "GetAttributesEnumeration": GetAttributesEnumeration,
    "GetCampaignOverview": GetCampaignOverview,
    "GetCampaignRecipients": GetCampaignRecipients,
    "GetCampaignStats": GetCampaignStats,
    "GetChildDomain": GetChildDomain,
    "GetChildDomains": GetChildDomains,
    "GetChildInfoApiKeys": GetChildInfoApiKeys,
    "GetChildInfoApiKeysV2": GetChildInfoApiKeysV2,
    "GetChildInfoApiKeysV3": GetChildInfoApiKeysV3,
    "GetChildInfoCredits": GetChildInfoCredits,
    "GetChildInfoStatistics": GetChildInfoStatistics,
    "GetChildrenList": GetChildrenList,
    "GetClient": GetClient,
    "GetContactCampaignStats": GetContactCampaignStats,
    "GetContactCampaignStatsClicked": GetContactCampaignStatsClicked,
    "GetContactCampaignStatsOpened": GetContactCampaignStatsOpened,
    "GetContactCampaignStatsTransacAttributes": GetContactCampaignStatsTransacAttributes,
    "GetContactCampaignStatsUnsubscriptions": GetContactCampaignStatsUnsubscriptions,
    "GetContactDetails": GetContactDetails,
    "GetContacts": GetContacts,
    "GetEmailCampaigns": GetEmailCampaigns,
    "GetEmailEventReport": GetEmailEventReport,
    "GetEmailEventReportEvents": GetEmailEventReportEvents,
    "GetExtendedCampaignOverviewSender": GetExtendedCampaignOverviewSender,
    "GetExtendedCampaignStats": GetExtendedCampaignStats,
    "GetExtendedClientAddress": GetExtendedClientAddress,
    "GetExtendedContactDetailsStatistics": GetExtendedContactDetailsStatistics,
    "GetExtendedContactDetailsStatisticsClicked": GetExtendedContactDetailsStatisticsClicked,
    "GetExtendedContactDetailsStatisticsLinks": GetExtendedContactDetailsStatisticsLinks,
    "GetExtendedContactDetailsStatisticsMessagesSent": GetExtendedContactDetailsStatisticsMessagesSent,
    "GetExtendedContactDetailsStatisticsOpened": GetExtendedContactDetailsStatisticsOpened,
    "GetExtendedContactDetailsStatisticsUnsubscriptions": GetExtendedContactDetailsStatisticsUnsubscriptions,
    "GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription": GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription,
    "GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription": GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription,
    "GetExtendedListCampaignStats": GetExtendedListCampaignStats,
    "GetFolder": GetFolder,
    "GetFolderLists": GetFolderLists,
    "GetFolders": GetFolders,
    "GetIp": GetIp,
    "GetIpFromSender": GetIpFromSender,
    "GetIps": GetIps,
    "GetIpsFromSender": GetIpsFromSender,
    "GetList": GetList,
    "GetLists": GetLists,
    "GetProcess": GetProcess,
    "GetProcesses": GetProcesses,
    "GetReports": GetReports,
    "GetReportsReports": GetReportsReports,
    "GetSendersList": GetSendersList,
    "GetSendersListIps": GetSendersListIps,
    "GetSendersListSenders": GetSendersListSenders,
    "GetSmsCampaignOverview": GetSmsCampaignOverview,
    "GetSmsCampaignStats": GetSmsCampaignStats,
    "GetSmsCampaigns": GetSmsCampaigns,
    "GetSmsEventReport": GetSmsEventReport,
    "GetSmsEventReportEvents": GetSmsEventReportEvents,
    "GetSmtpTemplateOverview": GetSmtpTemplateOverview,
    "GetSmtpTemplateOverviewSender": GetSmtpTemplateOverviewSender,
    "GetSmtpTemplates": GetSmtpTemplates,
    "GetSsoToken": GetSsoToken,
    "GetStatsByDomain": GetStatsByDomain,
    "GetTransacAggregatedSmsReport": GetTransacAggregatedSmsReport,
    "GetTransacEmailContent": GetTransacEmailContent,
    "GetTransacEmailContentEvents": GetTransacEmailContentEvents,
    "GetTransacEmailsList": GetTransacEmailsList,
    "GetTransacEmailsListTransactionalEmails": GetTransacEmailsListTransactionalEmails,
    "GetTransacSmsReport": GetTransacSmsReport,
    "GetTransacSmsReportReports": GetTransacSmsReportReports,
    "GetWebhook": GetWebhook,
    "GetWebhooks": GetWebhooks,
    "ManageIp": ManageIp,
    "PostContactInfo": PostContactInfo,
    "PostContactInfoContacts": PostContactInfoContacts,
    "PostSendFailed": PostSendFailed,
    "PostSendSmsTestFailed": PostSendSmsTestFailed,
    "RemainingCreditModel": RemainingCreditModel,
    "RemainingCreditModelChild": RemainingCreditModelChild,
    "RemainingCreditModelReseller": RemainingCreditModelReseller,
    "RemoveContactFromList": RemoveContactFromList,
    "RemoveCredits": RemoveCredits,
    "RequestContactExport": RequestContactExport,
    "RequestContactImport": RequestContactImport,
    "RequestContactImportNewList": RequestContactImportNewList,
    "RequestSmsRecipientExport": RequestSmsRecipientExport,
    "SendEmail": SendEmail,
    "SendEmailAttachment": SendEmailAttachment,
    "SendReport": SendReport,
    "SendReportEmail": SendReportEmail,
    "SendSms": SendSms,
    "SendSmtpEmail": SendSmtpEmail,
    "SendSmtpEmailAttachment": SendSmtpEmailAttachment,
    "SendSmtpEmailBcc": SendSmtpEmailBcc,
    "SendSmtpEmailCc": SendSmtpEmailCc,
    "SendSmtpEmailReplyTo": SendSmtpEmailReplyTo,
    "SendSmtpEmailSender": SendSmtpEmailSender,
    "SendSmtpEmailTo": SendSmtpEmailTo,
    "SendTemplateEmail": SendTemplateEmail,
    "SendTestEmail": SendTestEmail,
    "SendTestSms": SendTestSms,
    "SendTransacSms": SendTransacSms,
    "UpdateAttribute": UpdateAttribute,
    "UpdateAttributeEnumeration": UpdateAttributeEnumeration,
    "UpdateCampaignStatus": UpdateCampaignStatus,
    "UpdateChild": UpdateChild,
    "UpdateChildAccountStatus": UpdateChildAccountStatus,
    "UpdateChildDomain": UpdateChildDomain,
    "UpdateContact": UpdateContact,
    "UpdateEmailCampaign": UpdateEmailCampaign,
    "UpdateEmailCampaignRecipients": UpdateEmailCampaignRecipients,
    "UpdateEmailCampaignSender": UpdateEmailCampaignSender,
    "UpdateList": UpdateList,
    "UpdateSender": UpdateSender,
    "UpdateSmsCampaign": UpdateSmsCampaign,
    "UpdateSmtpTemplate": UpdateSmtpTemplate,
    "UpdateSmtpTemplateSender": UpdateSmtpTemplateSender,
    "UpdateWebhook": UpdateWebhook,
    "GetChildInfo": GetChildInfo,
    "GetExtendedCampaignOverview": GetExtendedCampaignOverview,
    "GetExtendedClient": GetExtendedClient,
    "GetExtendedContactDetails": GetExtendedContactDetails,
    "GetExtendedList": GetExtendedList,
    "GetSmsCampaign": GetSmsCampaign,
    "GetAccount": GetAccount,
    "GetEmailCampaign": GetEmailCampaign,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountApiApiKeys {
    apiKey,
    partnerKey,
}

export class AccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Get your account informations, plans and credits details
     */
    public getAccount () : Promise<{ response: http.ClientResponse; body: GetAccount;  }> {
        const localVarPath = this.basePath + '/account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributesApiApiKeys {
    apiKey,
    partnerKey,
}

export class AttributesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AttributesApiApiKeys, value: string) {
        (this.authentications as any)[AttributesApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Creates contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the attribute
     * @param createAttribute Values to create an attribute
     */
    public createAttribute (attributeCategory: string, attributeName: string, createAttribute: CreateAttribute) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'createAttribute' is not null or undefined
        if (createAttribute === null || createAttribute === undefined) {
            throw new Error('Required parameter createAttribute was null or undefined when calling createAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAttribute, "CreateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deletes an attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     */
    public deleteAttribute (attributeCategory: string, attributeName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling deleteAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling deleteAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Lists all attributes
     */
    public getAttributes () : Promise<{ response: http.ClientResponse; body: GetAttributes;  }> {
        const localVarPath = this.basePath + '/contacts/attributes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAttributes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAttributes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param updateAttribute Values to update an attribute
     */
    public updateAttribute (attributeCategory: string, attributeName: string, updateAttribute: UpdateAttribute) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'updateAttribute' is not null or undefined
        if (updateAttribute === null || updateAttribute === undefined) {
            throw new Error('Required parameter updateAttribute was null or undefined when calling updateAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAttribute, "UpdateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
    apiKey,
    partnerKey,
}

export class ContactsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        (this.authentications as any)[ContactsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Add existing contacts to a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses of the contacts
     */
    public addContactToList (listId: number, contactEmails: AddContactToList) : Promise<{ response: http.ClientResponse; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/add'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling addContactToList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling addContactToList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "AddContactToList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Creates contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the attribute
     * @param createAttribute Values to create an attribute
     */
    public createAttribute (attributeCategory: string, attributeName: string, createAttribute: CreateAttribute) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'createAttribute' is not null or undefined
        if (createAttribute === null || createAttribute === undefined) {
            throw new Error('Required parameter createAttribute was null or undefined when calling createAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAttribute, "CreateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a contact
     * @param createContact Values to create a contact
     */
    public createContact (createContact: CreateContact) : Promise<{ response: http.ClientResponse; body: CreateUpdateContactModel;  }> {
        const localVarPath = this.basePath + '/contacts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createContact' is not null or undefined
        if (createContact === null || createContact === undefined) {
            throw new Error('Required parameter createContact was null or undefined when calling createContact.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createContact, "CreateContact")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateUpdateContactModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateUpdateContactModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a folder
     * @param createFolder Name of the folder
     */
    public createFolder (createFolder: CreateUpdateFolder) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createFolder' is not null or undefined
        if (createFolder === null || createFolder === undefined) {
            throw new Error('Required parameter createFolder was null or undefined when calling createFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a list
     * @param createList Values to create a list
     */
    public createList (createList: CreateList) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createList' is not null or undefined
        if (createList === null || createList === undefined) {
            throw new Error('Required parameter createList was null or undefined when calling createList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createList, "CreateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deletes an attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     */
    public deleteAttribute (attributeCategory: string, attributeName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling deleteAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling deleteAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deletes a contact
     * @param email Email (urlencoded) of the contact
     */
    public deleteContact (email: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling deleteContact.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a folder (and all its lists)
     * @param folderId Id of the folder
     */
    public deleteFolder (folderId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling deleteFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a list
     * @param listId Id of the list
     */
    public deleteList (listId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling deleteList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Lists all attributes
     */
    public getAttributes () : Promise<{ response: http.ClientResponse; body: GetAttributes;  }> {
        const localVarPath = this.basePath + '/contacts/attributes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAttributes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAttributes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Retrieves contact informations
     * @param email Email (urlencoded) of the contact OR its SMS attribute value
     */
    public getContactInfo (email: string) : Promise<{ response: http.ClientResponse; body: GetExtendedContactDetails;  }> {
        const localVarPath = this.basePath + '/contacts/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling getContactInfo.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetExtendedContactDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedContactDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the campaigns statistics for a contact
     * @param email Email address (urlencoded) of the contact
     */
    public getContactStats (email: string) : Promise<{ response: http.ClientResponse; body: GetContactCampaignStats;  }> {
        const localVarPath = this.basePath + '/contacts/{email}/campaignStats'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling getContactStats.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetContactCampaignStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContactCampaignStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all the contacts
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     */
    public getContacts (limit?: number, offset?: number, modifiedSince?: Date) : Promise<{ response: http.ClientResponse; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "Date");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the contacts in a list
     * @param listId Id of the list
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getContactsFromList (listId: number, modifiedSince?: Date, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getContactsFromList.');
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns folder details
     * @param folderId id of the folder
     */
    public getFolder (folderId: number) : Promise<{ response: http.ClientResponse; body: GetFolder;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all the folders
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getFolders (limit: number, offset: number) : Promise<{ response: http.ClientResponse; body: GetFolders;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getFolders.');
        }

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getFolders.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolders;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolders");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the details of a list
     * @param listId Id of the list
     */
    public getList (listId: number) : Promise<{ response: http.ClientResponse; body: GetExtendedList;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetExtendedList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all the lists
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getLists (limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetLists;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input.
     * @summary Import contacts
     * @param requestContactImport Values to import contacts in Sendinblue. To know more about the expected format, please have a look at &#x60;&#x60;https://help.sendinblue.com/hc/en-us/articles/209499265-Build-contacts-lists-for-your-email-marketing-campaigns&#x60;&#x60;
     */
    public importContacts (requestContactImport: RequestContactImport) : Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/contacts/import';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestContactImport' is not null or undefined
        if (requestContactImport === null || requestContactImport === undefined) {
            throw new Error('Required parameter requestContactImport was null or undefined when calling importContacts.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestContactImport, "RequestContactImport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove existing contacts from a list
     * @param listId Id of the list
     * @param contactEmails Emails adresses of the contact
     */
    public removeContactFromList (listId: number, contactEmails: RemoveContactFromList) : Promise<{ response: http.ClientResponse; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/remove'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling removeContactFromList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling removeContactFromList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "RemoveContactFromList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input. File will be available in csv.
     * @summary Export contacts
     * @param requestContactExport Values to request a contact export
     */
    public requestContactExport (requestContactExport: RequestContactExport) : Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/contacts/export';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestContactExport' is not null or undefined
        if (requestContactExport === null || requestContactExport === undefined) {
            throw new Error('Required parameter requestContactExport was null or undefined when calling requestContactExport.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestContactExport, "RequestContactExport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param updateAttribute Values to update an attribute
     */
    public updateAttribute (attributeCategory: string, attributeName: string, updateAttribute: UpdateAttribute) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'updateAttribute' is not null or undefined
        if (updateAttribute === null || updateAttribute === undefined) {
            throw new Error('Required parameter updateAttribute was null or undefined when calling updateAttribute.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAttribute, "UpdateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates a contact
     * @param email Email (urlencoded) of the contact
     * @param updateContact Values to update a contact
     */
    public updateContact (email: string, updateContact: UpdateContact) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling updateContact.');
        }

        // verify required parameter 'updateContact' is not null or undefined
        if (updateContact === null || updateContact === undefined) {
            throw new Error('Required parameter updateContact was null or undefined when calling updateContact.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateContact, "UpdateContact")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a contact folder
     * @param folderId Id of the folder
     * @param updateFolder Name of the folder
     */
    public updateFolder (folderId: number, updateFolder: CreateUpdateFolder) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling updateFolder.');
        }

        // verify required parameter 'updateFolder' is not null or undefined
        if (updateFolder === null || updateFolder === undefined) {
            throw new Error('Required parameter updateFolder was null or undefined when calling updateFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a list
     * @param listId Id of the list
     * @param updateList Values to update a list
     */
    public updateList (listId: number, updateList: UpdateList) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling updateList.');
        }

        // verify required parameter 'updateList' is not null or undefined
        if (updateList === null || updateList === undefined) {
            throw new Error('Required parameter updateList was null or undefined when calling updateList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateList, "UpdateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EmailCampaignsApiApiKeys {
    apiKey,
    partnerKey,
}

export class EmailCampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EmailCampaignsApiApiKeys, value: string) {
        (this.authentications as any)[EmailCampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create an email campaign
     * @param emailCampaigns Values to create a campaign
     */
    public createEmailCampaign (emailCampaigns: CreateEmailCampaign) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/emailCampaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'emailCampaigns' is not null or undefined
        if (emailCampaigns === null || emailCampaigns === undefined) {
            throw new Error('Required parameter emailCampaigns was null or undefined when calling createEmailCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaigns, "CreateEmailCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete an email campaign
     * @param campaignId id of the campaign
     */
    public deleteEmailCampaign (campaignId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling deleteEmailCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Export the recipients of a campaign
     * @param campaignId Id of the campaign
     * @param recipientExport Values to send for a recipient export request
     */
    public emailExportRecipients (campaignId: number, recipientExport?: EmailExportRecipients) : Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/exportRecipients'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling emailExportRecipients.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(recipientExport, "EmailExportRecipients")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get campaign informations
     * @param campaignId Id of the campaign
     */
    public getEmailCampaign (campaignId: number) : Promise<{ response: http.ClientResponse; body: GetEmailCampaign;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getEmailCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetEmailCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Return all your created campaigns
     * @param type Filter on the type of the campaigns
     * @param status Filter on the status of the campaign
     * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param limit Number of documents per page
     * @param offset Index of the first document in the page
     */
    public getEmailCampaigns (type?: string, status?: string, startDate?: Date, endDate?: Date, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetEmailCampaigns;  }> {
        const localVarPath = this.basePath + '/emailCampaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetEmailCampaigns;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailCampaigns");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send an email campaign id of the campaign immediately
     * @param campaignId Id of the campaign
     */
    public sendEmailCampaignNow (campaignId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendNow'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendEmailCampaignNow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A PDF will be sent to the specified email addresses
     * @summary Send the report of a campaigns
     * @param campaignId Id of the campaign
     * @param sendReport Values for send a report
     */
    public sendReport (campaignId: number, sendReport: SendReport) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendReport'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendReport.');
        }

        // verify required parameter 'sendReport' is not null or undefined
        if (sendReport === null || sendReport === undefined) {
            throw new Error('Required parameter sendReport was null or undefined when calling sendReport.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendReport, "SendReport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send an email campaign to your test list
     * @param campaignId Id of the campaign
     * @param emailTo
     */
    public sendTestEmail (campaignId: number, emailTo: SendTestEmail) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendTest'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendTestEmail.');
        }

        // verify required parameter 'emailTo' is not null or undefined
        if (emailTo === null || emailTo === undefined) {
            throw new Error('Required parameter emailTo was null or undefined when calling sendTestEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailTo, "SendTestEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a campaign status
     * @param campaignId Id of the campaign
     * @param status Status of the campaign
     */
    public updateCampaignStatus (campaignId: number, status: UpdateCampaignStatus) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/status'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateCampaignStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateCampaignStatus.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "UpdateCampaignStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a campaign
     * @param campaignId Id of the campaign
     * @param emailCampaign Values to update a campaign
     */
    public updateEmailCampaign (campaignId: number, emailCampaign: UpdateEmailCampaign) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling updateEmailCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "UpdateEmailCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FoldersApiApiKeys {
    apiKey,
    partnerKey,
}

export class FoldersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FoldersApiApiKeys, value: string) {
        (this.authentications as any)[FoldersApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a folder
     * @param createFolder Name of the folder
     */
    public createFolder (createFolder: CreateUpdateFolder) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createFolder' is not null or undefined
        if (createFolder === null || createFolder === undefined) {
            throw new Error('Required parameter createFolder was null or undefined when calling createFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a folder (and all its lists)
     * @param folderId Id of the folder
     */
    public deleteFolder (folderId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling deleteFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns folder details
     * @param folderId id of the folder
     */
    public getFolder (folderId: number) : Promise<{ response: http.ClientResponse; body: GetFolder;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all the folders
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getFolders (limit: number, offset: number) : Promise<{ response: http.ClientResponse; body: GetFolders;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getFolders.');
        }

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getFolders.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolders;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolders");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a contact folder
     * @param folderId Id of the folder
     * @param updateFolder Name of the folder
     */
    public updateFolder (folderId: number, updateFolder: CreateUpdateFolder) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling updateFolder.');
        }

        // verify required parameter 'updateFolder' is not null or undefined
        if (updateFolder === null || updateFolder === undefined) {
            throw new Error('Required parameter updateFolder was null or undefined when calling updateFolder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ListsApiApiKeys {
    apiKey,
    partnerKey,
}

export class ListsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ListsApiApiKeys, value: string) {
        (this.authentications as any)[ListsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Add existing contacts to a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses of the contacts
     */
    public addContactToList (listId: number, contactEmails: AddContactToList) : Promise<{ response: http.ClientResponse; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/add'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling addContactToList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling addContactToList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "AddContactToList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Create a list
     * @param createList Values to create a list
     */
    public createList (createList: CreateList) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createList' is not null or undefined
        if (createList === null || createList === undefined) {
            throw new Error('Required parameter createList was null or undefined when calling createList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createList, "CreateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a list
     * @param listId Id of the list
     */
    public deleteList (listId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling deleteList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the contacts in a list
     * @param listId Id of the list
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getContactsFromList (listId: number, modifiedSince?: Date, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getContactsFromList.');
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the details of a list
     * @param listId Id of the list
     */
    public getList (listId: number) : Promise<{ response: http.ClientResponse; body: GetExtendedList;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetExtendedList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all the lists
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     */
    public getLists (limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetLists;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove existing contacts from a list
     * @param listId Id of the list
     * @param contactEmails Emails adresses of the contact
     */
    public removeContactFromList (listId: number, contactEmails: RemoveContactFromList) : Promise<{ response: http.ClientResponse; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/remove'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling removeContactFromList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling removeContactFromList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "RemoveContactFromList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a list
     * @param listId Id of the list
     * @param updateList Values to update a list
     */
    public updateList (listId: number, updateList: UpdateList) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling updateList.');
        }

        // verify required parameter 'updateList' is not null or undefined
        if (updateList === null || updateList === undefined) {
            throw new Error('Required parameter updateList was null or undefined when calling updateList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateList, "UpdateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessApiApiKeys {
    apiKey,
    partnerKey,
}

export class ProcessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessApiApiKeys, value: string) {
        (this.authentications as any)[ProcessApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Return the informations for a process
     * @param processId Id of the process
     */
    public getProcess (processId: number) : Promise<{ response: http.ClientResponse; body: GetProcess;  }> {
        const localVarPath = this.basePath + '/processes/{processId}'
            .replace('{' + 'processId' + '}', encodeURIComponent(String(processId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'processId' is not null or undefined
        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling getProcess.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetProcess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetProcess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Return all the processes for your account
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     */
    public getProcesses (limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetProcesses;  }> {
        const localVarPath = this.basePath + '/processes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetProcesses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetProcesses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ResellerApiApiKeys {
    apiKey,
    partnerKey,
}

export class ResellerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ResellerApiApiKeys, value: string) {
        (this.authentications as any)[ResellerApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Add Email and/or SMS credits to a specific child account
     * @param childAuthKey auth key of reseller&#39;s child
     * @param addCredits Values to post to add credit to a specific child account
     */
    public addCredits (childAuthKey: string, addCredits: AddCredits) : Promise<{ response: http.ClientResponse; body: RemainingCreditModel;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/credits/add'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling addCredits.');
        }

        // verify required parameter 'addCredits' is not null or undefined
        if (addCredits === null || addCredits === undefined) {
            throw new Error('Required parameter addCredits was null or undefined when calling addCredits.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addCredits, "AddCredits")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RemainingCreditModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Associate a dedicated IP to the child
     * @param childAuthKey auth key of reseller&#39;s child
     * @param ip IP to associate
     */
    public associateIpToChild (childAuthKey: string, ip: ManageIp) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/ips/associate'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling associateIpToChild.');
        }

        // verify required parameter 'ip' is not null or undefined
        if (ip === null || ip === undefined) {
            throw new Error('Required parameter ip was null or undefined when calling associateIpToChild.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ip, "ManageIp")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Creates a domain for a child account
     * @param childAuthKey auth key of reseller&#39;s child
     * @param addChildDomain Sender domain to add for a specific child account
     */
    public createChildDomain (childAuthKey: string, addChildDomain: AddChildDomain) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/domains'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling createChildDomain.');
        }

        // verify required parameter 'addChildDomain' is not null or undefined
        if (addChildDomain === null || addChildDomain === undefined) {
            throw new Error('Required parameter addChildDomain was null or undefined when calling createChildDomain.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addChildDomain, "AddChildDomain")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Creates a reseller child
     * @param resellerChild reseller child to add
     */
    public createResellerChild (resellerChild?: CreateChild) : Promise<{ response: http.ClientResponse; body: CreateReseller;  }> {
        const localVarPath = this.basePath + '/reseller/children';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerChild, "CreateChild")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateReseller;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateReseller");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deletes the sender domain of the reseller child based on the childAuthKey and domainName passed
     * @param childAuthKey auth key of reseller&#39;s child
     * @param domainName Pass the existing domain that needs to be deleted
     */
    public deleteChildDomain (childAuthKey: string, domainName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/domains/{domainName}'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)))
            .replace('{' + 'domainName' + '}', encodeURIComponent(String(domainName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling deleteChildDomain.');
        }

        // verify required parameter 'domainName' is not null or undefined
        if (domainName === null || domainName === undefined) {
            throw new Error('Required parameter domainName was null or undefined when calling deleteChildDomain.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Deletes a single reseller child based on the childAuthKey supplied
     * @param childAuthKey auth key of reseller&#39;s child
     */
    public deleteResellerChild (childAuthKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling deleteResellerChild.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Dissociate a dedicated IP to the child
     * @param childAuthKey auth key of reseller&#39;s child
     * @param ip IP to dissociate
     */
    public dissociateIpFromChild (childAuthKey: string, ip: ManageIp) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/ips/dissociate'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling dissociateIpFromChild.');
        }

        // verify required parameter 'ip' is not null or undefined
        if (ip === null || ip === undefined) {
            throw new Error('Required parameter ip was null or undefined when calling dissociateIpFromChild.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ip, "ManageIp")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Gets all the sender domains of a specific child account
     * @param childAuthKey auth key of reseller&#39;s child
     */
    public getChildDomains (childAuthKey: string) : Promise<{ response: http.ClientResponse; body: GetChildDomains;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/domains'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling getChildDomains.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetChildDomains;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildDomains");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Gets the info about a specific child account
     * @param childAuthKey auth key of reseller&#39;s child
     */
    public getChildInfo (childAuthKey: string) : Promise<{ response: http.ClientResponse; body: GetChildInfo;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling getChildInfo.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetChildInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Gets the list of all reseller's children accounts
     */
    public getResellerChilds () : Promise<{ response: http.ClientResponse; body: GetChildrenList;  }> {
        const localVarPath = this.basePath + '/reseller/children';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetChildrenList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildrenList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns a session [token] which will remain valid for a short period of time. A child account will be able to access a white-labeled section by using the following url pattern => https:/email.mydomain.com/login/sso?token=[token]
     * @summary Get session token to access Sendinblue (SSO)
     * @param childAuthKey auth key of reseller&#39;s child
     */
    public getSsoToken (childAuthKey: string) : Promise<{ response: http.ClientResponse; body: GetSsoToken;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/auth'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling getSsoToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSsoToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSsoToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Remove Email and/or SMS credits from a specific child account
     * @param childAuthKey auth key of reseller&#39;s child
     * @param removeCredits Values to post to remove email or SMS credits from a specific child account
     */
    public removeCredits (childAuthKey: string, removeCredits: RemoveCredits) : Promise<{ response: http.ClientResponse; body: RemainingCreditModel;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/credits/remove'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling removeCredits.');
        }

        // verify required parameter 'removeCredits' is not null or undefined
        if (removeCredits === null || removeCredits === undefined) {
            throw new Error('Required parameter removeCredits was null or undefined when calling removeCredits.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeCredits, "RemoveCredits")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RemainingCreditModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates infos of reseller's child account status based on the childAuthKey supplied
     * @param childAuthKey auth key of reseller&#39;s child
     * @param updateChildAccountStatus values to update in child account status
     */
    public updateChildAccountStatus (childAuthKey: string, updateChildAccountStatus: UpdateChildAccountStatus) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/accountStatus'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling updateChildAccountStatus.');
        }

        // verify required parameter 'updateChildAccountStatus' is not null or undefined
        if (updateChildAccountStatus === null || updateChildAccountStatus === undefined) {
            throw new Error('Required parameter updateChildAccountStatus was null or undefined when calling updateChildAccountStatus.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateChildAccountStatus, "UpdateChildAccountStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates the sender domain of reseller's child based on the childAuthKey and domainName passed
     * @param childAuthKey auth key of reseller&#39;s child
     * @param domainName Pass the existing domain that needs to be updated
     * @param updateChildDomain value to update for sender domain
     */
    public updateChildDomain (childAuthKey: string, domainName: string, updateChildDomain: UpdateChildDomain) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}/domains/{domainName}'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)))
            .replace('{' + 'domainName' + '}', encodeURIComponent(String(domainName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling updateChildDomain.');
        }

        // verify required parameter 'domainName' is not null or undefined
        if (domainName === null || domainName === undefined) {
            throw new Error('Required parameter domainName was null or undefined when calling updateChildDomain.');
        }

        // verify required parameter 'updateChildDomain' is not null or undefined
        if (updateChildDomain === null || updateChildDomain === undefined) {
            throw new Error('Required parameter updateChildDomain was null or undefined when calling updateChildDomain.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateChildDomain, "UpdateChildDomain")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates infos of reseller's child based on the childAuthKey supplied
     * @param childAuthKey auth key of reseller&#39;s child
     * @param resellerChild values to update in child profile
     */
    public updateResellerChild (childAuthKey: string, resellerChild: UpdateChild) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childAuthKey}'
            .replace('{' + 'childAuthKey' + '}', encodeURIComponent(String(childAuthKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'childAuthKey' is not null or undefined
        if (childAuthKey === null || childAuthKey === undefined) {
            throw new Error('Required parameter childAuthKey was null or undefined when calling updateResellerChild.');
        }

        // verify required parameter 'resellerChild' is not null or undefined
        if (resellerChild === null || resellerChild === undefined) {
            throw new Error('Required parameter resellerChild was null or undefined when calling updateResellerChild.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerChild, "UpdateChild")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SMSCampaignsApiApiKeys {
    apiKey,
    partnerKey,
}

export class SMSCampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SMSCampaignsApiApiKeys, value: string) {
        (this.authentications as any)[SMSCampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Creates an SMS campaign
     * @param createSmsCampaign Values to create an SMS Campaign
     */
    public createSmsCampaign (createSmsCampaign: CreateSmsCampaign) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/smsCampaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createSmsCampaign' is not null or undefined
        if (createSmsCampaign === null || createSmsCampaign === undefined) {
            throw new Error('Required parameter createSmsCampaign was null or undefined when calling createSmsCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSmsCampaign, "CreateSmsCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete the SMS campaign
     * @param campaignId id of the SMS campaign
     */
    public deleteSmsCampaign (campaignId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling deleteSmsCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get an SMS campaign
     * @param campaignId id of the SMS campaign
     */
    public getSmsCampaign (campaignId: number) : Promise<{ response: http.ClientResponse; body: GetSmsCampaign;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getSmsCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSmsCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns the informations for all your created SMS campaigns
     * @param status Status of campaign.
     * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     */
    public getSmsCampaigns (status?: string, startDate?: Date, endDate?: Date, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetSmsCampaigns;  }> {
        const localVarPath = this.basePath + '/smsCampaigns';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSmsCampaigns;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsCampaigns");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input.
     * @summary Exports the recipients of the specified campaign.
     * @param campaignId id of the campaign
     * @param recipientExport Values to send for a recipient export request
     */
    public requestSmsRecipientExport (campaignId: number, recipientExport?: RequestSmsRecipientExport) : Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/exportRecipients'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling requestSmsRecipientExport.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(recipientExport, "RequestSmsRecipientExport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send your SMS campaign immediately
     * @param campaignId id of the campaign
     */
    public sendSmsCampaignNow (campaignId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendNow'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendSmsCampaignNow.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send report of Sent and Archived campaign, to the specified email addresses, with respective data and a pdf attachment in detail.
     * @summary Send report of SMS campaigns
     * @param campaignId id of the campaign
     * @param sendReport Values for send a report
     */
    public sendSmsReport (campaignId: number, sendReport: SendReport) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendReport'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendSmsReport.');
        }

        // verify required parameter 'sendReport' is not null or undefined
        if (sendReport === null || sendReport === undefined) {
            throw new Error('Required parameter sendReport was null or undefined when calling sendSmsReport.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendReport, "SendReport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send an SMS
     * @param campaignId Id of the SMS campaign
     * @param phoneNumber Mobile number of the recipient with the country code. This number must belong to one of your contacts in SendinBlue account and must not be blacklisted
     */
    public sendTestSms (campaignId: number, phoneNumber: SendTestSms) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendTest'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendTestSms.');
        }

        // verify required parameter 'phoneNumber' is not null or undefined
        if (phoneNumber === null || phoneNumber === undefined) {
            throw new Error('Required parameter phoneNumber was null or undefined when calling sendTestSms.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(phoneNumber, "SendTestSms")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates an SMS campaign
     * @param campaignId id of the SMS campaign
     * @param updateSmsCampaign Values to update an SMS Campaign
     */
    public updateSmsCampaign (campaignId: number, updateSmsCampaign: UpdateSmsCampaign) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateSmsCampaign.');
        }

        // verify required parameter 'updateSmsCampaign' is not null or undefined
        if (updateSmsCampaign === null || updateSmsCampaign === undefined) {
            throw new Error('Required parameter updateSmsCampaign was null or undefined when calling updateSmsCampaign.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateSmsCampaign, "UpdateSmsCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update the campaign status
     * @param campaignId id of the campaign
     * @param status Status of the campaign.
     */
    public updateSmsCampaignStatus (campaignId: number, status: UpdateCampaignStatus) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/status'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateSmsCampaignStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateSmsCampaignStatus.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "UpdateCampaignStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SMTPApiApiKeys {
    apiKey,
    partnerKey,
}

export class SMTPApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SMTPApiApiKeys, value: string) {
        (this.authentications as any)[SMTPApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a transactional email template
     * @param smtpTemplate values to update in transactional email template
     */
    public createSmtpTemplate (smtpTemplate: CreateSmtpTemplate) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/smtp/templates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'smtpTemplate' is not null or undefined
        if (smtpTemplate === null || smtpTemplate === undefined) {
            throw new Error('Required parameter smtpTemplate was null or undefined when calling createSmtpTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smtpTemplate, "CreateSmtpTemplate")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
     * @summary Delete hardbounces
     * @param deleteHardbounces values to delete hardbounces
     */
    public deleteHardbounces (deleteHardbounces?: DeleteHardbounces) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/deleteHardbounces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteHardbounces, "DeleteHardbounces")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete an inactive transactional email template
     * @param templateId id of the template
     */
    public deleteSmtpTemplate (templateId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling deleteSmtpTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get your transactional email activity aggregated over a period of time
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Tag of the emails
     */
    public getAggregatedSmtpReport (startDate?: string, endDate?: string, days?: number, tag?: string) : Promise<{ response: http.ClientResponse; body: GetAggregatedReport;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/aggregatedReport';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAggregatedReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAggregatedReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all your transactional email activity (unaggregated events)
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param email Filter the report for a specific email addresses
     * @param event Filter the report for a specific event type
     * @param tags Filter the report for tags (serialized and urlencoded array)
     * @param messageId Filter on a specific message id
     * @param templateId Filter on a specific template id
     */
    public getEmailEventReport (limit?: number, offset?: number, startDate?: string, endDate?: string, days?: number, email?: string, event?: string, tags?: string, messageId?: string, templateId?: number) : Promise<{ response: http.ClientResponse; body: GetEmailEventReport;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (messageId !== undefined) {
            localVarQueryParameters['messageId'] = ObjectSerializer.serialize(messageId, "string");
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetEmailEventReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailEventReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get your transactional email activity aggregated per day
     * @param limit Number of documents returned per page
     * @param offset Index of the first document on the page
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD)
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD)
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Tag of the emails
     */
    public getSmtpReport (limit?: number, offset?: number, startDate?: string, endDate?: string, days?: number, tag?: string) : Promise<{ response: http.ClientResponse; body: GetReports;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetReports;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetReports");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns the template informations
     * @param templateId id of the template
     */
    public getSmtpTemplate (templateId: number) : Promise<{ response: http.ClientResponse; body: GetSmtpTemplateOverview;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling getSmtpTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSmtpTemplateOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmtpTemplateOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the list of transactional email templates
     * @param templateStatus Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false
     * @param limit Number of documents returned per page
     * @param offset Index of the first document in the page
     */
    public getSmtpTemplates (templateStatus?: boolean, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: GetSmtpTemplates;  }> {
        const localVarPath = this.basePath + '/smtp/templates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (templateStatus !== undefined) {
            localVarQueryParameters['templateStatus'] = ObjectSerializer.serialize(templateStatus, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSmtpTemplates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmtpTemplates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the personalized content of a sent transactional email
     * @param uuid Unique id of the transactional email that has been sent to a particular contact
     */
    public getTransacEmailContent (uuid: string) : Promise<{ response: http.ClientResponse; body: GetTransacEmailContent;  }> {
        const localVarPath = this.basePath + '/smtp/emails/{uuid}'
            .replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getTransacEmailContent.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTransacEmailContent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacEmailContent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
     * @summary Get the list of transactional emails on the basis of allowed filters
     * @param email Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent.
     * @param templateId Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email.
     * @param messageId Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent.
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month.
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
     */
    public getTransacEmailsList (email?: string, templateId?: number, messageId?: string, startDate?: string, endDate?: string) : Promise<{ response: http.ClientResponse; body: GetTransacEmailsList;  }> {
        const localVarPath = this.basePath + '/smtp/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "number");
        }

        if (messageId !== undefined) {
            localVarQueryParameters['messageId'] = ObjectSerializer.serialize(messageId, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTransacEmailsList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacEmailsList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint is deprecated. Prefer v3/smtp/email instead.
     * @summary Send a template
     * @param templateId Id of the template
     * @param sendEmail
     */
    public sendTemplate (templateId: number, sendEmail: SendEmail) : Promise<{ response: http.ClientResponse; body: SendTemplateEmail;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}/send'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling sendTemplate.');
        }

        // verify required parameter 'sendEmail' is not null or undefined
        if (sendEmail === null || sendEmail === undefined) {
            throw new Error('Required parameter sendEmail was null or undefined when calling sendTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendEmail, "SendEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SendTemplateEmail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SendTemplateEmail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a template to your test list
     * @param templateId Id of the template
     * @param sendTestEmail
     */
    public sendTestTemplate (templateId: number, sendTestEmail: SendTestEmail) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}/sendTest'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling sendTestTemplate.');
        }

        // verify required parameter 'sendTestEmail' is not null or undefined
        if (sendTestEmail === null || sendTestEmail === undefined) {
            throw new Error('Required parameter sendTestEmail was null or undefined when calling sendTestTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendTestEmail, "SendTestEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send a transactional email
     * @param sendSmtpEmail Values to send a transactional email
     */
    public sendTransacEmail (sendSmtpEmail: SendSmtpEmail) : Promise<{ response: http.ClientResponse; body: CreateSmtpEmail;  }> {
        const localVarPath = this.basePath + '/smtp/email';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sendSmtpEmail' is not null or undefined
        if (sendSmtpEmail === null || sendSmtpEmail === undefined) {
            throw new Error('Required parameter sendSmtpEmail was null or undefined when calling sendTransacEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendSmtpEmail, "SendSmtpEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSmtpEmail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSmtpEmail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Updates a transactional email templates
     * @param templateId id of the template
     * @param smtpTemplate values to update in transactional email template
     */
    public updateSmtpTemplate (templateId: number, smtpTemplate: UpdateSmtpTemplate) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling updateSmtpTemplate.');
        }

        // verify required parameter 'smtpTemplate' is not null or undefined
        if (smtpTemplate === null || smtpTemplate === undefined) {
            throw new Error('Required parameter smtpTemplate was null or undefined when calling updateSmtpTemplate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smtpTemplate, "UpdateSmtpTemplate")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SendersApiApiKeys {
    apiKey,
    partnerKey,
}

export class SendersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SendersApiApiKeys, value: string) {
        (this.authentications as any)[SendersApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a new sender
     * @param sender sender&#39;s name
     */
    public createSender (sender?: CreateSender) : Promise<{ response: http.ClientResponse; body: CreateSenderModel;  }> {
        const localVarPath = this.basePath + '/senders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sender, "CreateSender")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSenderModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSenderModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a sender
     * @param senderId Id of the sender
     */
    public deleteSender (senderId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling deleteSender.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Return all the dedicated IPs for your account
     */
    public getIps () : Promise<{ response: http.ClientResponse; body: GetIps;  }> {
        const localVarPath = this.basePath + '/senders/ips';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetIps;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetIps");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Return all the dedicated IPs for a sender
     * @param senderId Id of the sender
     */
    public getIpsFromSender (senderId: number) : Promise<{ response: http.ClientResponse; body: GetIpsFromSender;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}/ips'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling getIpsFromSender.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetIpsFromSender;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetIpsFromSender");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get the list of all your senders
     * @param ip Filter your senders for a specific ip (available for dedicated IP usage only)
     * @param domain Filter your senders for a specific domain
     */
    public getSenders (ip?: string, domain?: string) : Promise<{ response: http.ClientResponse; body: GetSendersList;  }> {
        const localVarPath = this.basePath + '/senders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (ip !== undefined) {
            localVarQueryParameters['ip'] = ObjectSerializer.serialize(ip, "string");
        }

        if (domain !== undefined) {
            localVarQueryParameters['domain'] = ObjectSerializer.serialize(domain, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSendersList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSendersList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a sender
     * @param senderId Id of the sender
     * @param sender sender&#39;s name
     */
    public updateSender (senderId: number, sender?: UpdateSender) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling updateSender.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sender, "UpdateSender")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionalSMSApiApiKeys {
    apiKey,
    partnerKey,
}

export class TransactionalSMSApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionalSMSApiApiKeys, value: string) {
        (this.authentications as any)[TransactionalSMSApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Get all the SMS activity (unaggregated events)
     * @param limit Number of documents per page
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param offset Index of the first document of the page
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param phoneNumber Filter the report for a specific phone number
     * @param event Filter the report for specific events
     * @param tags Filter the report for specific tags passed as a serialized urlencoded array
     */
    public getSmsEvents (limit?: number, startDate?: string, endDate?: string, offset?: number, days?: number, phoneNumber?: string, event?: string, tags?: string) : Promise<{ response: http.ClientResponse; body: GetSmsEventReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSmsEventReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsEventReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get your SMS activity aggregated over a period of time
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param days Number of days in the past including today (positive integer). Not compatible with startDate and endDate
     * @param tag Filter on a tag
     */
    public getTransacAggregatedSmsReport (startDate?: string, endDate?: string, days?: number, tag?: string) : Promise<{ response: http.ClientResponse; body: GetTransacAggregatedSmsReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/aggregatedReport';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTransacAggregatedSmsReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacAggregatedSmsReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get your SMS activity aggregated per day
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Filter on a tag
     */
    public getTransacSmsReport (startDate?: string, endDate?: string, days?: number, tag?: string) : Promise<{ response: http.ClientResponse; body: GetTransacSmsReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetTransacSmsReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacSmsReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Send the SMS campaign to the specified mobile number
     * @param sendTransacSms Values to send a transactional SMS
     */
    public sendTransacSms (sendTransacSms: SendTransacSms) : Promise<{ response: http.ClientResponse; body: SendSms;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/sms';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sendTransacSms' is not null or undefined
        if (sendTransacSms === null || sendTransacSms === undefined) {
            throw new Error('Required parameter sendTransacSms was null or undefined when calling sendTransacSms.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendTransacSms, "SendTransacSms")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SendSms;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SendSms");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
    apiKey,
    partnerKey,
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'apiKey'),
        'partnerKey': new ApiKeyAuth('header', 'partnerKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a webhook
     * @param createWebhook Values to create a webhook
     */
    public createWebhook (createWebhook: CreateWebhook) : Promise<{ response: http.ClientResponse; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createWebhook' is not null or undefined
        if (createWebhook === null || createWebhook === undefined) {
            throw new Error('Required parameter createWebhook was null or undefined when calling createWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createWebhook, "CreateWebhook")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Delete a webhook
     * @param webhookId Id of the webhook
     */
    public deleteWebhook (webhookId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling deleteWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get a webhook details
     * @param webhookId Id of the webhook
     */
    public getWebhook (webhookId: number) : Promise<{ response: http.ClientResponse; body: GetWebhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling getWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetWebhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetWebhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Get all webhooks
     * @param type Filter on webhook type
     */
    public getWebhooks (type?: string) : Promise<{ response: http.ClientResponse; body: GetWebhooks;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetWebhooks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetWebhooks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Update a webhook
     * @param webhookId Id of the webhook
     * @param updateWebhook Values to update a webhook
     */
    public updateWebhook (webhookId: number, updateWebhook: UpdateWebhook) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling updateWebhook.');
        }

        // verify required parameter 'updateWebhook' is not null or undefined
        if (updateWebhook === null || updateWebhook === undefined) {
            throw new Error('Required parameter updateWebhook was null or undefined when calling updateWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateWebhook, "UpdateWebhook")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
